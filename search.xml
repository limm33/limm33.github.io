<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ansible使用playbook总结]]></title>
    <url>%2F2018%2F12%2F30%2FLinux%2Fansible%E4%BD%BF%E7%94%A8playbook%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[原文 http://limingming.org/index.php/2018/12/ansible-playbook-use-summ/ SSH免密钥登录设置使用ssh-keygen生成key-pair： 123456789101112131415161718192021ssh-keygen -t rsa -P ''# 以下为系统输出内容：Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Created directory '/root/.ssh'.Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:03:4a:1c:e1:7b:ca:84:11:2e:4e:4a:d7:d0:a3:83:d2 root@localhost.localdomainThe key's randomart image is:+--[ RSA 2048]----+| ..+. || . +o+ ||.++.=.o ||*oE* o . ||o.. = . S || o o . || o || || |+-----------------+ 从上面就可以看到密钥存储在了/root/.ssh/id_rsa,将该文件夹下的id_rsa.pub内容配置到被控制的机子的/root/.ssh/authorized_keys文件中。 重新ssh连接一次，就不需要密码了：1234567[root@localhost .ssh]# ssh root@10.111.24.67The authenticity of host '10.111.24.67 (10.111.24.67)' can't be established.ECDSA key fingerprint is ee:87:55:3a:d4:96:9e:c7:78:0e:a8:c1:8b:26:d3:75.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '10.111.24.67' (ECDSA) to the list of known hosts.Last login: Tue Dec 25 11:08:54 2018 from 10.9.11.40[root@localhost ~]# 配置Ansible使用Ansible需要配置/etc/anisble/路径下的hosts和ansible.cfg文件，需要使用root权限修改，默认安装成功后应该不存在这两个文件，所以需要创建： 1234567mkdir -p /etc/ansible vi /etc/ansible/ansible.cfg# 写入内容# remote_port 这个设置是你系统默认的远程SSH端口,如果不指定,默认为22号端口[defaults]remote_port = 22private_key_file = /root/.ssh/id_rsa 以上配置文件修改可以参考地址 Ansibleke可以操作属于同一个组的多个主机，组和主机之间的关系通过 inventory 文件(INI 格式)配置，默认的文件路径为 /etc/ansible/hosts，一个系统可以属于不同的组，比如一台服务器可以同时属于A组和B组，还有C组，所以修改host文件： 1234vi /etc/ansible/hosts# 写入内容[test]10.111.24.67 除了配置以上的host文件之外，还可以配置环境变量引用文件路径： 1export ANSIBLE_HOSTS=~/test/qiuyi_ansible/test_hosts playbook一个playbook中可以包含多个play。每个play都至少包含有tasks和hosts这两项，还可以包含其他非必须项，如vars,vars_files,remote_user等。tasks中可以通过模块调用定义一系列的action。只不过，绝大多数时候，一个playbook都只定义一个play。123playbook: [play1,play2,play3]play: [hosts,tasks,vars,remote_user...]tasks: [module1,module2,...] 需要注意，有些时候play中使用了role，可能看上去没有tasks，这是因为role本身就是整合playbook的，所以没有也没关系。但没有使用role的时候，必须得包含hosts和tasks。ansilbe提供了2种方式去执行完成任务，一个是playbook，一个是ad-hoc,ad-hoc只可以做一些简单的操作，如果要部署的话最好采用playbook来做，即是：ansible-palybook命令；通过上面的配置，我们现在可以放心的看一下ansible-playbook有哪些参数： 12345678910[root@localhost ~]# ansible-playbook --helpUsage: ansible-playbook [options] playbook.yml [playbook2 ...]Runs Ansible playbooks, executing the defined tasks on the targeted hosts.Options: --ask-vault-pass ask for vault password -C, --check don&apos;t make any changes; instead, try to predict some# 等等··· Playbooks适合部署复杂的应用，能用在声明配置，可以编排有序的执行过程，本文主要是记录并整理部署应用的过程，我要部署的应用大约包含部署tomcat及web应用，还有执行安装相关的python应用等 基础语法playbook使用了YAML格式的语法，编程少不了使用配置文件，yaml文件也是作为配置文件格式的一个主要方式，比如我经常用的使用markdown编写博客的HEXO，就是经常改动yaml文件，所以说，YAML是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。 如果感兴趣可以参考YAML语言介绍 12345大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略 在test组（我们上面说到的配置/etc/ansible/hosts）使用root用户执行安装wget命令，如下： 123456- hosts: test remote_user: root gather_facts: True tasks: - name: "安装wget命令" command: yum -y insatll wget hosts也可以使用ip的方式，每个ip用逗号隔开 语法注意：”-“以及”:”后面都需要一个空格，从上面可以看出，有两个基本的属性，一个是hosts，一个是remote_user,他们可以定位到我们需啊哟执行命令的主机，定义tasks就可以执行task的一些命令了，上面的例子中是执行安装wget的命令，playbook执行任务需要通过不同的模块进行控制。从上面的实例可以看出有两个必须的属性，那就是服务器主机hosts以及远程用户remote_user，有了它们就可以干点其它事了tasks，自然而然在playbook执行任务是需要通过模块的来操控的。使用命令检查yaml的语法: 1ansible-playbook main.yml --syntax-check command在上面举例中也是使用command执行安装wget命令： 123456- hosts: test remote_user: root gather_facts: True tasks: - name: "安装wget命令" command: yum -y insatll wget shell我们也可以使用shell替换到command： 123456- hosts: test remote_user: root gather_facts: True tasks: - name: "安装wget命令" shell: yum -y insatll wget script执行shell脚本： 123456- hosts: test remote_user: root gather_facts: True tasks: - name: "被控节点执行控制节点的shell脚本" script: /home/limm/test.sh copy将控制节点的文件上传到test服务器【被控节点】上:1234567891011- hosts: test remote_user: root gather_facts: True tasks: - name: "控节点文件复制到到被控制节点服务器" copy: src=/home/limm/dialog.war dest=/opt/limm/apache-tomcat/webapps/ owner=root group=root mode=0644 src代表控制节点路径，dest代表被控节点路径，其它的为可选项目 yum使用yum安装vim,yum该模块仅仅适合contOS相似的发行版：123456- hosts: test remote_user: root gather_facts: True tasks: - name: &quot;安装vim&quot; yum: name=vim state=latest name为安装软件的名称state为安装的版本 servicetest用户组以root用户重启apache2服务：123456- hosts: test remote_user: root gather_facts: True tasks: - name: "重启apache2服务" service: name=apache2 state=restarted 我们平时启动可能使用systemctl restart httpd这种，但是在state中需要使用加-ed的方式，如： stsrted stoped restarted； notify 与 handlersnotify这个action可用于在每个play的最后被触发，这样可以避免多次有改变发生时每次都执行指定的操作，在notify中列出的操作称为handler，也即notify中调用handler中定义的操作。Handlers 也是一些 task 的列表,通过名字来引用,它们和一般的 task 并没有什么区别，Handlers 是由通知者进行 notify, 如果没有被 notify,handlers 不会执行。不管有多少个通知者进行了 notify,等到 play 中的所有 task 执行完成之后,handlers 也只会被执行一次。Handlers 最佳的应用场景是用来重启服务,或者触发系统重启操作。 12345678910- hosts: test remote_user: root tasks: - name: "test notify" shell: ls notify: - restart apache2 handlers: - name: restart apache2 service: name=apache2 state=restarted vars在playbook中定义变量1234567- hosts: test remote_user: root vars: config_path: &quot;/root/application/sise.conf&quot; tasks: - name: &quot;test notify&quot; command: touch &#123;&#123;config_path&#125;&#125; Ansible允许你使用Jinja2模板系统在playbook中引用变量，加上引号 “，在执行ansible脚本的时候赋值：例如：1234567- hosts: &#123;&#123;hosts&#125;&#125; remote_user: root vars: config_path: "/root/application/sise.conf" tasks: - name: "test notify" command: touch &#123;&#123;config_path&#125;&#125; 执行脚本：123ansible-playbook main.yml --extra-vars hosts=test#如果有多个参数：ansible-playbook release.yml --extra-vars "version=1.23.45 other_variable=foo" Roles、includeRoles是ansible自1.2版本引入的新特性，用于层次性，结构化地组织playbook，roles能够根据层次型结构自动自动装在变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中。role构建的项目目录：12345678910111213141516171819site.ymlcmd.ymlroles/ common/ files/ templates/ tasks/ handlers/ vars/ defaults/ meta/ web/ files/ templates/ tasks/ handlers/ vars/ defaults/ meta/ Role内各目录可用的文件：123456789101112131415tasks目录：至少创建一个名为main.yml的文件，其定义了此角色的任务列表：此文件可以使用 include包含其他的位于此目录中的tasks文件：files目录：存放由copy或者script等模块调用的文件：templates目录：templates模块会自动在此目录中寻找Jinjia2模板文件：handlers目录：此目录中应当包含一个main。yml文件：用于定义此角色用到的各handler：在handler中使用include包含的其他的handler文件也应该位于此目录中：vars目录：应当包含一个main.yml文件，用于定义此角色用到的变量meta目录：应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系：ansible 1.3及其以后的版本才支持default目录：为当前角色定义默认变量时使用此目录，应该包含一个main.yml文件 而在playbook（site.yml）中可以这样使用roles： 12345---- hosts: test roles: - common - web 也可以向roles传递参数，例如： 12345---- hosts: test roles: - common - &#123; role: foo_app_instance , dir: '/opt/a', port: 8080 &#125; 可以给roles指定tags，使用ansible-playbook -t指定此roles的tags，使用roles都应该定义tags： 12345---- hosts: test roles: - &#123; role: common , tags: "common"&#125; - web 只执行common的角色：1ansible-playbook -t common -i /etc/ansible/hosts site.yml -vv include使用语法：1- include: cmd.yml 补充 查看任务所指定的host列表 1$ ansible-playbook main.yml --list-hosts –ask-pass、–ask-sudo-pass普通用户执行命令需要输入密码 1$ ansible-playbook main.ym --ask-sudo-pass --ask-pass]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>使用</tag>
        <tag>ansible</tag>
        <tag>总结</tag>
        <tag>playbook</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAML语言介绍]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C%2FYAML%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[原文： http://limingming.org/index.php/2018/12/yaml-intro 介绍YAML（/ˈjæməl/，尾音类似camel骆驼）是一个可读性高，用来表达数据序列的格式。YAML参考了其他多种语言，包括：C语言、Python、Perl，并从XML、邮箱的数据格式（RFC 2822）中获得灵感。Clark Evans在2001年首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。当前已经有数种编程语言或脚本语言支持（或者说解析）这种语言。 YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。– 维基百科 上面我们也看到了YAML Ain’t a Markup Language，这个让我想起了，GNU对UNIX来说不，YAML是对XML说不，所以YAML应该是试图用一种比XML更敏捷的方式，来完成XML所完成的任务，在我们编程过程中很多时候会用到YAML文件编写配置文件，如果使用java的话可能用的比较多的是properties的配置文件居多，但是很多时候也会用到YAML文件，比如我经常使用的HEXO，修改比较多的就是YAML文件。 概括YAML的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态，下面主要针对于YAML文件相关语法做简要的记录，我平时用的比较多的是JAVA，所以针对于java也有很多YAML的实现，如果按照语法来说的话YAML文件几乎可以总结成： Structure通过空格来展示。Sequence里的项用”-“来代表，Map里的键值对用”:”分隔. 抽象出来的的对象,java里面Map、Hash这种 Collection相关的List、Set这种 单一的int这种 Structure通过空格来展示，可以组合成javabean这种对象，Sequence可以实现Arrays等，：分割实现对象、Map类的数据结构，外加其他的数据类型，可以涵盖所有的我们常用的数据类型。1234YAML大小写敏感；使用缩进代表层级关系；缩进只能使用空格，不能使用TAB，不要求空格个数，只需要相同层级左对齐（一般2个或4个空格）使用#注释 语法对象数据类型使用冒号，冒号后面跟一个空格，缩紧表示层级关系 12345keyFirst: valuekey: key1: value1 key2:value2 还可以支持行内语法表示对象： 1key: &#123;key1: value, key2: value2&#125; 数组使用一个短横线加一个空格代表一个数组项： 123- value1- value2- value3 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。12345678910- - value1 - valu2 - value3# 如果上面作为作为value的话就是：key:- - value1 - valu2 - value3 数组也同样可以使用行内：1key: [value1, value2] 举一个复杂的例子： 123456789key: - key1: value key2: value key3: value - key4: value key5: value key6: value 上面这种写法也是可以的，可以对应的是一个list的value，list中包含两个map对象； 单一常量YAML中提供了多种常量结构，包括：整数，浮点数，字符串，NULL，日期，布尔，时间，常量是最基本的、不可再分的值。 12345678910111213141516171819boolean: - TRUE #true,True都可以 - FALSE #false，False都可以float: - 3.14 - 6.8523015e+5 #可以使用科学计数法int: - 123 - 0b1010_0111_0100_1010_1110 #二进制表示null: nodeName: &apos;node&apos; parent: ~ #使用~表示nullstring: - 你好 - &apos;Hello&apos; #可以使用双引号或者单引号包裹特殊字符date: - 2018-02-17 #日期必须使用ISO 8601格式，即yyyy-MM-dddatetime: - 2018-02-17T15:02:31+08:00 #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区 其他 引用使用锚点：&amp;别名：* 重复的内容在YAML中可以使用&amp;来完成锚点定义，使用*来完成锚点引用，例如：123456key:- value1 - &amp;mark1 value2key2:- *mark1 - value3 上面中使用*mark1相当于替代了value2，那么key2的第一个元素应该是value2； 还可以：定义复杂的：1234key1: &amp;mark2 - value3 - value4key2: *mark2 上面的*mark2相当于定义了key1中的数组内容，但要注意的是需要和key2写在一行还有不能单独定义锚点，如：&amp;mark value1，这种形式是不可以的 补充：和锚点配合使用的还可能是合并内容，例如： 12345key1: - &amp;mark1 &#123; key2: value2, key3: value3 &#125;key11: &lt;&lt;: *mark1 key4: value4 那么上面通过 &lt;&lt;: *mark1 这种方式就将key11变成了：1234key11: key2: value2 key3: value3 key4: value4 通过合并内容可以有效的共用相同的配置。 三个短横线 YAML文件中，可以使用— 表示文档的开始，Springboot中profile的定义就是如此，可以一个YAML文件中，包含多个profile，每个—都是一个profile的开始，例如：12345678910111213server: address: 192.168.1.100---spring: profiles: development server: address: 127.0.0.1 ---spring: profiles: production server: address: 192.168.1.120 …和—配合使用来表示配置文件中一个文件的结束 类型转换!! 表示强制的类型转换： 12string: - !!str 54321 折叠换行与保留换行在字符串中折叠换行，| 保留换行符 例如： 123456key1: &gt; 1 2 3 4 5 6key2: | 7 8 9 10 11 12 那么key1=1 2 3 4 5 6，就是没有保留换行符，将黄换行符转换成了空格； 而key2 12key2=7 8 9 10 11 12 key2 保留的换行符。 注释 使用”#”来表示注释]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>介绍</tag>
        <tag>语法</tag>
        <tag>YAML</tag>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim编辑器使用]]></title>
    <url>%2F2018%2F12%2F29%2FLinux%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原文 介绍平时在使用linux like系统的时候肯定接触过vim，拿“鸟哥”的话来说的话就是，文本模式来处理Linux 的系统设置，不但可以让你比较容易了解到Linux的运行状况，也比较容易了解整个设计的基本思想，基本上我们接触的类linux系统都有vim编辑器，虽然有着繁杂的命令，但是基本上都是靠键盘输入，编辑文件简单快速，虽然在大学学习的时候总感觉为什么不用word，这玩意这么难用，为什么还要用这个玩意，到了慢慢熟悉使用vi之后才知道这个才是好的编辑器。 vi使用模式vi操作有很多，此文仅记录常用的相关操作，及vi的几种模式，分别是命令模式（command mode）、插入模式（Insert mode）和命令行模式（last line mode），各模式的功能区分如下： 一般模式（command mode）控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 插入模式（Insert mode）只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 命令行模式（last line mode）将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 基本操作进入vi : 1vi 文件路径/文件名 进入之后处于一般模式，如果要切换到插入模式可以使用i、o、a： 按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件；按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 如果要回到命令行模式「ESC」可以帮你退回到一般模式，在「一般模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，常用的进入命令行模式，一般进入命令行模式会执行一些操作，例如保存并退出“：wq”，例如设置展示行号，“：se nu” 例如查找某些单词：“：/word”等等 一般模式下按键操作 移动光标但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格翻页：按「ctrl」+「b」：屏幕往“后”移动一页。按「ctrl」+「f」：屏幕往“前”移动一页。按「ctrl」+「u」：屏幕往“后”移动半页。按「ctrl」+「d」：屏幕往“前”移动半页。 常用跳到行头和行尾：按数字「0」：移到文章的开头，按「$」：移动到光标所在行的“行尾” G相关：G： 移动到这个文件最后一行nG：n为数字移动到这个文件的第n行gg： 移动到文件的第一行，相当于1GN【Enter】 ： N为数字，向下移动N行 复制粘贴 「yw」：将光标所在之处到字尾的字符。「#yw」：复制#个字到缓冲区「yy」：复制光标所在行（常用）「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。(常用)「p」： 粘贴 删除 x： 删除当前光标下的字符X； 删除光标前面的字符dw； 删除从当前光标到单词结尾的字符d^; 删除从当前光标到行首的字符d$ ;删除从当前光标到行尾的字符D ;删除从当前光标到行尾的字符dd 删除当前光标所在的行(常用)ndd： n是数字，删除光标所在行向下n行 撤销、重做u： 复原前一个操作Ctrl+r，重做上一个操作. ： 小数点，重复前一个操作 命令行模式操作 列出行号set nu 定位到某行#：井号代表一个数字，在Lastline mode提示符号“：”前输入数字，再按Enter就会跳到该行了，等同于在一般模式下的#G 寻找字符串/关键字：先按/，再输入您想寻找的字(字母“n”为向下继续查找)？关键字：先按？，再输入您想寻找的字(字母“n”为向下继续查找) 取代字符串1，$s/string/replae/g：在lastline mode输入“1，$s/string/replace/g”会将全文的string字符串取代为replace字符串，其中1,$s就是指搜寻区间为文章从头至尾的意思，g则是表示全部取代不必确认%s/string/replace/c：同样会将全文的string字符串取代为replace字符串，和上面指令不同的地方是，%s和1,$s是相同的功能，c则是表示要替代之前必须再次确认是否取代1,20s/string/replace/g：将1至20行间的string替代为relpace字符串 存储w：在lastline mode提示符号“：”前按w即可将文件保存#，# wfilename：如果您想摘取文章的某一段，存成另一个文件，可用这个指令#代表行号，例如30,50 wnice，将您正在编辑文章的第30~50行存成nice这个文件。 离开q：按q就离开，有时如果无法离开vi，可搭配“！：强置离开vi，如“q！”qw：一般建议离开时，搭配w一起使用，如此离开时还可存文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vi</tag>
        <tag>编辑器</tag>
        <tag>使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos常见配置修改]]></title>
    <url>%2F2018%2F12%2F26%2FLinux%2Fcentos%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[原文: http://limingming.org/index.php/2018/12/linux-common-config-vi/ 字符集在登录系统的时候经常会看到乱码的情况，经常会修改配置utf-8解决中文乱码的问题； centos6.5和centos7修改系统默认字符集的方式有所改变，通过执行命令修改配置的方式是一样的： 查看系统支持的字符集 1locale -a centos6.5修改系统字符集 临时生效：1234LANG="zh_CN.utf8"echo $LANG# 显示zh_CN.utf8 永久生效：123vim /etc/sysconfig/i18n# 编辑内容LANG=&quot;zh_CN.utf8&quot; centos7修改系统字符集 临时生效的方式和Centos6.5设置一样； 永久生效需要修改配置文件/etc/locale.conf： 123vim /etc/locale.conf # 编辑内容LANG="zh_CN.utf8" 时间设置时区 查看当前时区 1date -R 修改设置Linux服务器时区 方法一 1tzselect 方法二 仅限于RedHat Linux 和 CentOS 1timeconfig 替换系统时区文件 1cp /usr/share/zoneinfo/$主时区/$次时区 /etc/localtime 例如设置为上海的时区，但是需要注意的是，如果你设置的时间是北京时间早上7点，可能你执行覆盖上海的时区的时候会加一个小时，变成早上8点，因为上海属于东9区。1cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 修改时间 查看时间和日期 1date 设置时间和日期例如：将系统日期设定成2018年12月26日,晚上9点18分25秒 12date -s 12/26/2018date -s 21:18:25 将当前时间和日期写入BIOS，避免重启后失效 1hwclock -w cal 命令cal命令可以用来显示公历（阳历）日历。公历是现在国际通用的历法，又称格列历，通称阳历 1cal [参数][月份][年份]]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>修改</tag>
        <tag>Centos</tag>
        <tag>日期</tag>
        <tag>字符集</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven无法下载构件]]></title>
    <url>%2F2018%2F12%2F25%2FMaven%2Fmaven%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E6%9E%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/maven-u-clean-install/ was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced -&gt; [Help 1][ERROR] 或许你遇到过这个错误，我看到这个错误的时候以为我配置的私服无法连接网络，其实并不是私服的问题，我执行了： 1find ./ -name "*.lastUpdated" -exec grep -q "Could not transfer" &#123;&#125; \; -print -exec rm &#123;&#125; \; 删除LastUpdate文件，但是有时候好使有时候不好使，可能是因为开着eclipse的原因吧，刚删除可能它自己有请求有生成了一个。 所以采取了一个简单的方法： 1mvn -U clean install 就会重新下载了，或者也可以修改配置使用私服的地方： 1234567891011121314151617&lt;profiles&gt; &lt;profile&gt; ... &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;myRepo&lt;/id&gt; &lt;name&gt;My Repository&lt;/name&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;/repositories&gt; ... &lt;/profile&gt; &lt;/profiles&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>无法</tag>
        <tag>Maven</tag>
        <tag>下载</tag>
        <tag>构件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[syntax error near unexpected token $ do 报错问题]]></title>
    <url>%2F2018%2F12%2F22%2FLinux%2Fsyntax-error-near-unexpected-token-do-r%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原文： http://limingming.org/index.php/2018/12/syntax-error-nea…pected-token-dor/ 介绍不知道大家有没有在windows上面编写shell脚本，然后部署到linux上运行的经历，如果你做过类似的事情，那你可能遇到过这个问题：syntax error near unexpected token $’do\r”，或者类似的问题。 运行shell脚本shell脚本，运行出错：syntax error near unexpected token$’do\r 问题原因Linux和windows下的回车换行符不兼容 文件格式区别 很久以前，人们用老式的电传打字机作为输入设备，它使用两个字符来另起新行。一个字符把滑动架移回首位 (称为回车:，另一个字符把纸上移一行(称为换行:)， 当计算机问世后，由于存储器曾经非常昂贵。有些人就认定没必要用两个字符来表示行尾。于是UNIX 开发者决定他们可以用即，一个字符来表示行尾。Apple 开发者规定了用。开发 MS-DOS (以及微软视窗) 的那些家伙则决定沿用老式的 三种行尾格式如下: 1231. unix为： &lt;LF&gt; : /n 2. dos为： &lt;CR&gt;&lt;LF&gt; : /r/n3. mac为： &lt;CR&gt; : /r 所以这也是为什么window将的文件转移到unix上会出现syntax error near unexpected token `$’do\r”的原因。 问题解决 在windows上可以用文本编辑器查看所有字符，例如notepad++，视图-&gt;显示符号-&gt;显示所有符号在每行的结尾显示了CRLF的符号问题正是由此产生的。 用文本编辑器解决办法，eclipse等编辑器都可以解决，拿notepad++来说，编辑-&gt;档案格式转换-&gt;转换为UNIX格式，再放到linux上运行就不会出现以上报错了。 使用dos2unix工具进行处理 在linux上安装dos2unix工具：sudo apt-get install dos2unix（根据系统使用不同命令安装），安装成功后可以定义一个shell脚本，或者手动执行一下命令： 1dos2unix *.sh 输出：dos2unix: converting file eval1.sh to Unix format … 就将这个文件转换为了linux下的执行文件了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>do\r</tag>
        <tag>字符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS常见问题记录]]></title>
    <url>%2F2018%2F12%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2FmacOS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[安装第三方应用Mac安装第三方应用时提示”*.app”已损坏,打不开.这是因为安装权限问题,把隐私偏好设置的”允许所有来源”安装选项即可.新版Mac系统默认隐藏了”允许任何来源”隐藏了.使用sudo spctl –master-disable命令打开即可. 打开终端程序执行命令： 1sudo spctl --master-disable 然后输入你的密码就可以了 MAC打开多个Eclipse空间Mac上打开多个Eclipse方法是：找到Eclipse.app的位置，在Terminal中cd到这个目录 然后执行： 1open -n Eclipse.app]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>MAC</tag>
        <tag>OS</tag>
        <tag>常见</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j2使用]]></title>
    <url>%2F2018%2F12%2F22%2FJava%2Flog4j2%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/log4j2-user-config/ 介绍log4j 兼容jdk6， 最新版本是1.2.17（不再进行更新），log4j2 不兼容jdk7之前的版本。但是，log4j 2 采用了异步写文件的机制，比log4j 提高了10倍以上的性能，log4j组件2.4以后的版本能够支持.properties格式的配置文件（之前的2.x版均不支持.properties配置），新版properties格式配置文件与其他格式（XML格式、JSON格式文件等）一样，配置的主要任务是完成对各类插件及其属性的定义。 xml 配置在spring boot2.1.1.RELEASE中配置使用log4j2： 123456789101112131415161718192021222324252627&lt;!-- Exclude Spring Boot's Default Logging --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;!-- Add Log4j2 Dependency --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 无厘头的问题使用以上配置之后出现了异常： 123456objc[24414]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home/bin/java (0x1045c54c0) and /Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home/jre/lib/libinstrument.dylib (0x1055ef4e0). One of the two will be used. Which one is undefined.SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/Users/limm/.m2/repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/Users/limm/.m2/repository/org/apache/logging/log4j/log4j-slf4j-impl/2.11.1/log4j-slf4j-impl-2.11.1.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder] 所以尝试排除各种依赖解决这个异常错误，但是排除了各种依赖，都没有解决这个问题，干脆重新删掉项目在eclipse中重新执行了一下： 1mvn clean eclipse:eclipse 然后重新导入到eclipse中，发现这个错误竟然好了，我真的对这个东西无语了，姑且认为我的这个错误是因为eclipse导致的吧，但是我更愿意相信可能我在操作这个的过程中，修改的某个地方但是我忘记了。但是第二天我重新建立一个项目，pom中配置的内容一样还是出现了上面的问题，我没有做其他任何操作重新执行了上面的步骤异常就消失了，我到写这个博客的日子还没有抛弃eclipse，具体来说应该是sts，接下来我可能换IDEA了。 XML配置文件我使用的是Spring boot2.1.1,所以log4j2 为2.1.1版本，所以我们用通用的xml配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--日志级别排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status="ERROR" monitorInterval="60"&gt; &lt;Properties&gt; &lt;!-- 下文中通过$&#123;log.path&#125;获取这个配置路径 --&gt; &lt;Property name="log.path"&gt;/Users/limm/log/dialog-demo-web&lt;/Property&gt; &lt;/Properties&gt; &lt;!--先定义所有的appender--&gt; &lt;appenders&gt; &lt;!--这个输出控制台的配置--&gt; &lt;console name="Console" target="SYSTEM_OUT"&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern="[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"/&gt; &lt;/console&gt; &lt;File name="log" fileName="$&#123;log.path&#125;/test.log" append="false"&gt; &lt;PatternLayout pattern="[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"/&gt; &lt;/File&gt; &lt;RollingFile name="RollingFileInfo" fileName="$&#123;log.path&#125;/info.log" filePattern="$&#123;log.path&#125;/logs/$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;.log.zip"&gt; &lt;!--只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level="info" onMatch="ACCEPT" onMismatch="DENY"/&gt; &lt;PatternLayout pattern="[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy modulate="true" interval="1"/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt; &lt;logger name="org.springframework" level="INFO"/&gt; &lt;logger name="org.mybatis" level="INFO"/&gt; &lt;logger name="com.inspur.demo.web" level="INFO"/&gt; &lt;root level="info"&gt; &lt;appender-ref ref="Console"/&gt; &lt;appender-ref ref="RollingFileInfo"/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 启动过程中遇到： 12018-12-21 20:23:58,444 main INFO Log4j appears to be running in a Servlet environment, but there&apos;s no log4j-web module available. If you want better web container support, please add the log4j-web JAR to your web archive or server lib directory. 添加了依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-web&lt;/artifactId&gt;&lt;/dependency&gt; XML配置语法 根节点属性根节点有两个属性，一个是status，一个是monitorinterval， status用来指定log4j2本身的日志的级别，我们上面的xml中为WARNmonitorinterval用于指定log4j自动监测间隔时间，单位是s,最小是5s Properties 标签在xml文件中，可以使用Properties 标签来自定义变量，方便其他地方的引用，当然用的最多的是通过log.path获取log，输出的跟路径。 123&lt;Properties&gt; &lt;Property name="log.path"&gt;这里写日志输入的跟路径&lt;/Property&gt;&lt;/Properties&gt; Appenders 节点 我们上面log4j中提到Appender，Appender是用来定义日志输出点的，一般常用有三个子节点，分别为Console、RollingFile、File，也可以参考log4j,下面介绍一下各个子节点的用处及常用的属性 Console节点用来定义输出到控制台的Appender： name : 指定Appender的名字，用于Logger节点引用 target : SYSTEM_OUT 或 SYSTEM_ERR,一般设置为:SYSTEM_OUT PatternLayout : 指定日志输出格式，默认为%m%n 1234&lt;console name="Console" target="SYSTEM_OUT"&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern="[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"/&gt;&lt;/console&gt; File节点用来定义输出到指定位置的文件的Appender: name : 和console一样，指定Appender的名字，用于Logger节点引用 fileName : 指定输出日志的目的文件带全路径的文件名 append : 是否追加，默认为ture。ture是将新日志追加到原日志文件尾部，false则是删除已有文件，重建新文件 PatternLayout : 指定日志输出格式，默认为%m%n 123&lt;File name="log" fileName="log/test.log" append="false"&gt; &lt;PatternLayout pattern="[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"/&gt;&lt;/File&gt; 上面的File节点指定输出文件位置的Appender，但是对于文件输入的约束是很弱的，而RollingFile节点也用来定义输出到指定位置的文件的Appender,但是却灵活的多，记录的文件内容可进行详细的拆分，例如对于文件大小，根据时间等： name : 指定Appender的名字，用于Logger节点引用 fileName : 指定输出日志的目的文件带全路径的文件名 filePattern:指定拆分出去的日志文件的全路径的文件名以及格式 PatternLayout : 指定日志输出格式，默认为%m%n Policies : 指定滚动日志的策略，就是什么时候进行新建日志文件输出日志. TimeBasedTriggeringPolicy : 基于时间进行日志的滚动 SizeBasedTriggeringPolicy : 基于文件大小进行日志的滚动 ThresholdFilter : 日志过滤器 1234567891011121314151617181920212223&lt;RollingFile name="RollingFileInfo" fileName="$&#123;log.path&#125;/info.log" filePattern="$&#123;log.path&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log.zip"&gt; &lt;!--只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level="info" onMatch="ACCEPT" onMismatch="DENY"/&gt; &lt;PatternLayout pattern="[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy modulate="true" interval="1"/&gt; &lt;/Policies&gt;&lt;/RollingFile&gt; &lt;!-- 一般般情况下都使用RollingRandomAccessFile，RollingRandomAccessFile可以按照日志名称的格式进行定期备份，拥有一定的备份策略。 1.是否压缩备份日志：直接在filePattern属性的文件名称最后加对应的压缩后缀，如gzip压缩用 .gz --&gt; &lt;RollingRandomAccessFile name="errorFile" fileName="$&#123;fileName&#125;/mic-error.log" filePattern="$&#123;fileGz&#125;/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.mic-error.gz"&gt; &lt;PatternLayout&gt; &lt;pattern&gt;%d %p %C&#123;1.&#125; [%t] %m%n&lt;/pattern&gt; &lt;/PatternLayout&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval="6" modulate="true" /&gt; &lt;SizeBasedTriggeringPolicy size="10 MB"/&gt; &lt;/Policies&gt; &lt;!-- 指定每天的最大压缩包个数，默认7个，超过了会覆盖之前的 --&gt; &lt;DefaultRolloverStrategy max="50"/&gt; &lt;/RollingRandomAccessFile&gt; Ps:TimeBasedTriggeringPolicy这个滚动策略的属性interval，它是指日志进行滚动的间隔，那么它的单位具体是什么呢？关键点在于filePattern的日志文件名所含有的日期格式%d{yyyy-MM-dd},这里日期格式具体到了天，那么以天为单位，若是日期具体到%d{yyyy-MM-dd-HH-mm}分钟的话，那么就是以分钟为单位。 Loggers节点 Loggers节点下一般会配置root和logger节点，root节点用来指定项目的根日志，如果没有单独指定logger，那么就会默认使用该root日志输出。 level ：日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF. appender-ref ：root的子节点，用来指定该日志输出到哪个Appender 1234&lt;root level="info"&gt; &lt;appender-ref ref="Console"/&gt; &lt;appender-ref ref="RollingFileInfo"/&gt;&lt;/root&gt; Logger节点用来单独指定日志的形式，比如要为某个包下所有的class或者某个具体的class指定不同的日志级别等。 level : 日志输出级别 name : 用来指定该Logger所适用的类或者包. AppenderRef ：Logger的子节点，用来指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root additivity ：是否向上级传递日志 true(默认)或false 1234&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;&lt;logger name="org.springframework" level="INFO"/&gt;&lt;logger name="org.mybatis" level="INFO"/&gt;&lt;logger name="com.baiding" level="INFO"/&gt; 若我们为logger指定了AppenderRef ，别忘了将logger的additivity 属性设置为false,要不然日志可能会在指定的Appender中输出两遍 Log4j2异步输出日志Log4j2突出新特性支持高效低延迟的异步化写日志，日志异步优点是单独的进程打印日志，可以提高日志执行效率，减少日志功能对正常业务的影响。使用了disruptor这个开源的并发框架进行日志的异步输出，所以首先得导入disruptor.jar包 12345&lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt; 异步输出模式 全异步 异步和非异步混合输出 异步和非异步混合模式，性能还是比较好的，这种模式的启用，主要在于两个节点的使用，分别为AsyncRoot和AsyncLogger,这两个节点可以和Root 或 Logger节点混合使用。 123456789&lt;loggers&gt; &lt;AsyncRoot level="info"&gt; &lt;appender-ref ref="Console"/&gt; &lt;appender-ref ref="RollingFileInfo"/&gt; &lt;/AsyncRoot&gt; &lt;AsyncLogger name="com.baiding" level="INFO" /&gt; &lt;AsyncLogger name="org.mybatis" level="INFO" /&gt; &lt;AsyncLogger name="org.springframework" level="INFO" /&gt;&lt;/loggers&gt; 参考配置文件模版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- 在运行时，可以动态修改配置文件，不用重启服务，在固定时长更新一次配置文件。monitorInterval设置更新配置文件时长， 单位为seconds ， min senconds &gt;= 5secondes --&gt; &lt;Configuration monitorInterval="30" &gt; &lt;Properties&gt; &lt;Property name="log.path"&gt;E:\log4j2_log\&lt;/Property&gt; &lt;/Properties&gt; &lt;Appenders&gt; &lt;!-- 控制台appdener--&gt; &lt;Console name="STDOUT" target="SYSTEM_OUT"&gt; &lt;PatternLayout charset="UTF-8" pattern="%m%n"/&gt; &lt;/Console&gt; &lt;!-- File appdener--&gt; &lt;File name="MyFile" fileName="logs/app.log" bufferedIO="true" &gt; &lt;PatternLayout&gt; &lt;Charset&gt;UTF-8&lt;/Charset&gt; &lt;Pattern&gt;%d %p %c&#123;1.&#125; [%t] %m%n&lt;/Pattern&gt; &lt;/PatternLayout&gt; &lt;/File&gt; &lt;!-- RandomAccessFile 性能高于 File--&gt; &lt;RandomAccessFile name="MyFile" fileName="logs/RandomAccessFile.log" &gt; &lt;PatternLayout&gt; &lt;Charset&gt;UTF-8&lt;/Charset&gt; &lt;Pattern&gt;%d %p %c&#123;1.&#125; [%t] %m%n&lt;/Pattern&gt; &lt;/PatternLayout&gt; &lt;/RandomAccessFile&gt; &lt;!--&lt;RollingFile&gt;&lt;/RollingFile&gt;--&gt; &lt;!-- 注意：一般情况下都使用RollingRandomAccessFile 。 RollingRandomAccessFile可以按照日志名称的格式进行定期备份，拥有一定的备份策略。 1.是否压缩备份日志：直接在filePattern属性的文件名称最后加对应的压缩后缀，如gzip压缩用 .gz --&gt; &lt;RollingRandomAccessFile name="RollingRandomAccessFile" fileName="logs/RollingRandomAccessFile.log" filePattern="logs/RollingRandomAccessFile-%d&#123;yyyy-MM-dd&#125;-%i.log.gz"&gt; &lt;PatternLayout&gt; &lt;Pattern&gt;%d %p %c&#123;1.&#125; [%t] %m%n&lt;/Pattern&gt; &lt;/PatternLayout&gt; &lt;!-- 备份策略:满足其中一个就可以启动备份--&gt; &lt;Policies&gt; &lt;!-- interval 多久执行一次备份，单位为 RollingRandomAccessFile的属性filePattern中%d&#123;yyyy-MM-dd&#125;的最小时间单位，此处是天--&gt; &lt;TimeBasedTriggeringPolicy interval="1" modulate="true"/&gt; &lt;SizeBasedTriggeringPolicy size="250 MB"/&gt; &lt;/Policies&gt; &lt;!-- 默认的备份策略：max="7"表示最多只保留7份日志，fileIndex属性是在拥有多个备份日志的时候，命令是以递增的数为文件名，max值时值大的文件是最新的内容，min值时值大的是最久的内容--&gt; &lt;DefaultRolloverStrategy fileIndex="max" max="7"&gt; &lt;!-- 删除指定目录下60天之前的日志--&gt; &lt;Delete basePath="$&#123;log.path&#125;" maxDepth="2"&gt; &lt;IfFileName glob="*/app-*.log.gz" /&gt; &lt;IfLastModified age="60d" /&gt; &lt;/Delete&gt; &lt;/DefaultRolloverStrategy&gt; &lt;/RollingRandomAccessFile&gt; &lt;!-- 异步 appder ,使用的是ArrayBlocingQueue --&gt; &lt;Async name="Async"&gt; &lt;AppenderRef ref="MyFile"/&gt; &lt;/Async&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level="error"&gt; &lt;AppenderRef ref="MyFile"/&gt; &lt;/Root&gt; &lt;!-- logger additivity属性：如果设置为true（默认值）则log会被打印两次，这里的logger和root--&gt; &lt;Logger name="com.foo.bar.MyApp" level="info" additivity="true"&gt; &lt;appender-ref ref="RandomAccessFile"/&gt; &lt;/Logger&gt; &lt;!-- 异步 logger：使用了disruptor类库，代替Jdk中的queue，性能提高很多 includeLocation属性是指layout中的 %C or $class, %F or %file, %l or %location, %L or %line, %M or %method，异步logger默认为false，如果设置为true，会影响logger的性能 --&gt; &lt;AsyncLogger name="com.foo.test" level="info" additivity="false" includeLocation="false"&gt; &lt;appender-ref ref="log4j2test"/&gt; &lt;appender-ref ref="STDOUT"/&gt; &lt;/AsyncLogger&gt; &lt;/Loggers&gt; &lt;/Configuration&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>使用</tag>
        <tag>介绍</tag>
        <tag>log4j2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot2.x日志体系问题]]></title>
    <url>%2F2018%2F12%2F21%2FSpring%2Fspring-boot2-x%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/spring-boot2-x-log-config/ 介绍原来一直使用spring mvc，spring框架是3.6.2.配置的是log4j的日志，使用slf4j的log4j结合的方式，最近开发一个新的项目，我搭建了spring boot1.3.6.RELEASE的框架，能使用集成log4j,但是确实有冲突的问题，一直报logback有冲突的信息：12345SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/Users/limm/.m2/repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/Users/limm/.m2/repository/org/slf4j/slf4j-log4j12/1.6.1/slf4j-log4j12-1.6.1.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder] 操作：123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 通过依赖树进行了各种排除，才能解决不使用slf4j，使用log4j输出日志，但是接下来进行了spring boot的升级，升级之后才发现springboot 2.x版本不支持log4j了，支持log4j2，既然log4j2是它本来支持的所以准备换成log4j2,配置文件是xml支持原来的log4j.properties，key value的properties文件了。 经过这一番折腾，才发现日志这个体系太繁杂了，所以想梳理一下日志相关的这个体系。 日志体系见的Java日志框架有log4j、logback、j.u.l (java.util.logging)，常用的日志门面，SLF4J、commons-logging，其中，j.u.l是Java原生库，但是在Java 1.4中才被引用； commons-logging出自Apache，用于桥接j.u.l和log4j；log4j、logback和SLF4J出自同一个作者。出现的时间顺序： log4j—&gt;j.u.l—-&gt; commons-logging—–&gt;SLF4J—-&gt;logback log4j在JDK 1.3及以前，Java打日志System.err.println()或者e.printStackTrace()，或者这样根本不算是完善的日志，Debug日志被写到STDOUT流，错误日志被写到STDERR流，这样的日志无法定制，日志粒度小，哪里有压迫哪里就有反抗，哪里有问题，哪里就有有解决问题的办法，所以log4j应运而生，如果感兴趣可以看一下log4j使用。 j.u.l在log4j之后，可能是受到了log4j的启发，Sun在Java1.4版本中引入了java.util.logging，但是不如log4j完善，需要开发人员编写Appenders（Sun称之为Handlers）。 commons-logging第三个出现的是commons-logging，是一个API bridge，可以兼容上面的两个框架，然而commons-logging对Log4j和j.u.l的配置问题兼容的并不好，使用commons-loggings还可能会遇到类加载问题，导致NoClassDefFoundError的错误出现，或许你也经常会遇到这个问题。 SLF4J看到上面的这些问题，可能log4j的作者忍不住了（纯属我个人观点），他发起了SLF4j，只要使用SLF4J提供的接口，即可隐藏日志的具体实现，SLF4J提供的核心API是一些接口和一个LoggerFactory的工厂类，大大简便了开发人员的日志配置，方便使用。 logbacklogback和log4j是同一个作者创作，可以认为logback比log4j有更多的优点。 Spring 依赖日志包日志框架出现先看一下spring boot 2.1.1.RELEASE版本依赖的日志： 从上图可以看出，Spring Boot通过jul-to-slf4j.jar去适配了我们上面提到的JUL日志框架，通过log4j-to-slf4j.jar去适配了log4j日志框架。Spring5.x相对于Spring4.x去除了原来默认使用的JCL 框架，而是采用SLF4j这个通用的日志门面，所以Spring Boot2.x相对于Spring Boot1.x来说去除了对JCL的适配。 SpringBoot能自动适配所有的日志，其底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要 把这个框架依赖的日志框架排除掉即可，因为Spring Boot会通过自己的jar去替代； logback日志级别logbac日志级别从低到高分别为TRACE, DEBUG, INFO, WARN, ERROR 配置文件：logback.xml也可以命名为logback-spring.xml , logback-spring.groovy , logback.xml ，logback.groovy，上面提到的更多优点，也包含这个，支持多种格式的配置文件。 以xml为例：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;spring-boot-logging&lt;/contextName&gt; &lt;property name="log.path" value="log" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 级别过滤 --&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;log.path&#125;/spring-boot-logging.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/spring-boot-logging.%d&#123;yyyy-MM-dd&#125;.log.zip&lt;/fileNamePattern&gt; &lt;!-- 日志保存周期 --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!-- 总大小 --&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="file" /&gt; &lt;/root&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name="com.baiding"/&gt;&lt;/configuration&gt; log4j2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--日志级别排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status="WARN" monitorInterval="30"&gt; &lt;Properties&gt; &lt;Property name="log.path"&gt;log&lt;/Property&gt; &lt;/Properties&gt; &lt;!--先定义所有的appender--&gt; &lt;appenders&gt; &lt;!--这个输出控制台的配置--&gt; &lt;console name="Console" target="SYSTEM_OUT"&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern="[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"/&gt; &lt;/console&gt; &lt;File name="log" fileName="$&#123;log.path&#125;/test.log" append="false"&gt; &lt;PatternLayout pattern="[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"/&gt; &lt;/File&gt; &lt;RollingFile name="RollingFileInfo" fileName="$&#123;log.path&#125;/info.log" filePattern="$&#123;log.path&#125;/logs/$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;.log.zip"&gt; &lt;!--只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level="info" onMatch="ACCEPT" onMismatch="DENY"/&gt; &lt;PatternLayout pattern="[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy modulate="true" interval="1"/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!--然后定义logger，只有定义了logger并引入appender，appender才会生效--&gt; &lt;loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt; &lt;logger name="org.springframework" level="INFO"/&gt; &lt;logger name="org.mybatis" level="INFO"/&gt; &lt;logger name="com.baiding" level="INFO"/&gt; &lt;root level="info"&gt; &lt;appender-ref ref="Console"/&gt; &lt;appender-ref ref="RollingFileInfo"/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>spring</tag>
        <tag>输出</tag>
        <tag>体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j使用]]></title>
    <url>%2F2018%2F12%2F19%2FJava%2Flog4j%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原文:http://limingming.org/index.php/2018/12/log4j-use-log/ log4j介绍Log4j由三个组件构成： 日志信息的优先级 日志输出级别优先级：ERROR、WARN、 INFO、DEBUG，从名称就可以看出显示的为日志的重要级别程度 日志信息的输出目的地 日志信息的输出目的地指定了日志将打印到控制台还是输出到文件中 日志信息的输出格式 而输出格式则控制了日志信息内容的显示格式 引用包这里引用包是在spring boot低版本的时候支持，spring boot高版本支持log4j2了，下面我们会有相关的记录。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;/dependency&gt; 上面是列举的在spring boot中使用log4j,继承父项目中的版本，版本应该是1.3.2.RELEASE版本，如果其他项目可以自己指定log4j的版本，使用maven的话可以有相关联的间接依赖包，如下图： 配置配置文件在使用log4j中是至关重要的，但是也可以不采用配置文件，可以在代码中配置log4j的使用，但是会比较零散，而且不灵活，配置文件的配置方式又分为xml格式的配置文件和键值对类型的配置文件。 properties文件123456789101112131415161718192021222324252627282930313233343536LOG_DIR=/Users/limm/log/dialog-demo-web# Set root category priority to WARN and its only appender to FILE.log4j.rootLogger=INFO,tracelog4j.logger.com.inspur.dialog.demo.web=DEBUG,projectlog4j.additivity.com.inspur.dialog.demo=false#spring日志监控log4j.logger.org.springframework.web=INFO,springlog4j.additivity.org.springframework=false# 控制台输出log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L - %m%n#spring日志打印log4j.appender.spring=org.apache.log4j.RollingFileAppenderlog4j.appender.spring.File=$&#123;LOG_DIR&#125;/spring.loglog4j.appender.spring.MaxFileSize=5000000log4j.appender.spring.layout=org.apache.log4j.PatternLayoutlog4j.appender.spring.layout.ConversionPattern==[%d&#123;ISO8601&#125;] %-5p %-x %X&#123;user&#125; %n %m%nlog4j.appender.trace=org.apache.log4j.RollingFileAppenderlog4j.appender.trace.File=$&#123;LOG_DIR&#125;/trace.loglog4j.appender.trace.MaxFileSize=5000000log4j.appender.trace.layout=org.apache.log4j.PatternLayoutlog4j.appender.trace.layout.ConversionPattern=[%d&#123;ISO8601&#125;] %-5p %-x %X&#123;user&#125; %n %m%nlog4j.appender.project=org.apache.log4j.RollingFileAppenderlog4j.appender.project.File=$&#123;LOG_DIR&#125;/dialog-demo-web.loglog4j.appender.project.MaxFileSize=5000000log4j.appender.project.layout=org.apache.log4j.PatternLayoutlog4j.appender.project.layout.ConversionPattern=[%d&#123;ISO8601&#125;] %-5p %-x %X&#123;user&#125; %n %m%n 配置跟语法： 123log4j.rootLogger = [ level ] , appenderName, appenderName, …# level可以为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL，也可以允许自定义，log4j建议使用我们开头所说的那四类级别：ERROR、WARN、INFO、DEBUG 通过level的定义，我们能控制日志的输入级别，如果定义为WARN的话，那INFO和DEBUG讲不会输出；通过appenderName控制日志输出的位置，可以指定多个输出的目的地。 配置输出位置1234log4j.appender.appenderName = appender类的全路径限定类名称log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.option = valueN 上面提到的“appender类的全路径限定类名称”有以下几种： org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 日志信息的输出格式1234log4j.appender.appenderName.layout =layout类的全路径限定类名称log4j.appender.appenderName.layout.option1 = value1 … log4j.appender.appenderName.layout.option = valueN “layout类的全路径限定类名称”： org.apache.log4j.HTMLLayout（以HTML表格形式布局） org.apache.log4j.PatternLayout（可以灵活地指定布局模式） org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） log4j采用类似于C语言中print函数格式化日志信息，参数如下： 12345678%m 输出代码中的指定消息%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n” %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) 代码中使用123456789101112131415161718192021package org.limingming.springboot.web;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author limm on 2018/06/03 */@RestControllerpublic class Log4jController &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping("/test") public String sayHello()&#123; logger.info("这里是log4j使用的demo"); return "Hello,World!"; &#125;&#125; 或许你已经发现了，我们使用的是slf4j：import org.slf4j.Logger;import org.slf4j.LoggerFactory;如果我们直接使用log4j的话可能就变成了： 1234567891011121314151617181920package org.limingming.springboot.web;import org.apache.log4j.Logger;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author limm on 2018/06/03 */@RestControllerpublic class Log4jController &#123; private Logger logger = Logger.getLogger(this.getClass()); @RequestMapping("/test") public String sayHello()&#123; logger.error("异常", e); return "Hello,World!"; &#125;&#125; SLF4J不同于其他日志类库，与其它有很大的不同。SLF4J(Simple logging Facade for Java)不是一个真正的日志实现，而是一个抽象层（ abstraction layer），它允许你在后台使用任意一个日志类库。 SLF4J在语法上比log4j有更优的处理： 代码简化 log4j： 123if (logger.isDebugEnabled()) &#123; logger.debug("Processing trade with id: " + id + " symbol: " + symbol);&#125; slf4j: 1logger.debug("Processing trade with id: &#123;&#125; and symbol : &#123;&#125; ", id, symbol); 联想补充： e.printStackTrace()不会做任何操作，不会输出到日志，只会打印到控制台信息，不要使用这种方式 log.error(e.getMessage()）log4j的话，只能够输出异常信息，但是并不包括异常堆栈，不能定位到准确的出错信息 log.error(e)log4j，除了输出异常信息外，还能输出异常类型，但是同样不包括异常堆栈 显示堆栈信息的话可以采用上面我们给出的例子的那种方式：log.error(Object var1, Throwable var2); 使用java 包： 123slf4j-api-1.6.1.jar – JAR for SLF4J APIlog4j-1.2.16.jar – JAR for Log4J APIslf4j-log4j12-1.6.1.jar – Log4J Adapter for SLF4J 如果使用maven的话： 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt; 如果在spring boot中使用的话，引用可能会的导致冲突的异常，无法让日志生效，需要从spring中排除掉依赖的包！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>使用</tag>
        <tag>log4j</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot 部署到tomcat中注意事项]]></title>
    <url>%2F2018%2F12%2F18%2FSpring%2FSpring-boot-%E9%83%A8%E7%BD%B2%E5%88%B0tomcat%E4%B8%AD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/spring-boot-deploy-to-tomcat/ 介绍一般我们使用spring boot是使用内嵌的容器，一般不会将其部署到tomcat容器里，但是会有一些情况需要我们部署spring boot到tomcat中，部署过程中遇到一些问题，特此记录。 修改Application类如果你没有修改你的Application类就直接部署到tomcat中肯定会遇到一些无法请求到后台的服务的问题，只可以访问前端页面，修改你的Application类如下： 123456789@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class&#125;) public class Application extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(Application.class); &#125; &#125; 如果我们用jar包启动，流程是执行SpringBootApplication的run方法,启动IOC容器,然后创建嵌入式Servlet容器，war包流程是先是启动Servlet服务器,服务器启动Springboot应用(springBootServletInitizer),然后启动IOC容器，根据Servlet3.0+规则，tomcat启动过程中会经过一系列的过程，最终会找到每个相关的WebApplicationInitilizer调用自己的onstartup方法，WebApplicationInitializer有个抽象实现类SpringBootServletInitializer（继承这个这个类），则会调用每一个WebApplicationInitializer实例（包括SpringBootServletInitializer）的onStartup方法。实例执行onStartup方法的时候会通过createRootApplicationContext方法来执行run方法，那这个过程就意味着，我们启动就和jar包启动一样了，如果你启动tomcat过程中仔细观看打印信息，也会注意到这一点。 SpringBootServletInitializer即是一个org.springframework.web.context.WebApplicationContext，容器启动时会调用其onStartup(ServletContext servletContext)方法，主要方法就是createRootApplicationContext（servletContext）方法。 12345678910111213public void onStartup(ServletContext servletContext) throws ServletException &#123; this.logger = LogFactory.getLog(this.getClass()); final WebApplicationContext rootAppContext = this.createRootApplicationContext(servletContext); if(rootAppContext != null) &#123; servletContext.addListener(new ContextLoaderListener(rootAppContext) &#123; public void contextInitialized(ServletContextEvent event) &#123; &#125; &#125;); &#125; else &#123; this.logger.debug("No ContextLoaderListener registered, as createRootApplicationContext() did not return an application context"); &#125; &#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>部署</tag>
        <tag>tomcat</tag>
        <tag>Spring</tag>
        <tag>boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos下各种源的配置方式]]></title>
    <url>%2F2018%2F12%2F17%2FLinux%2Fcentos%E4%B8%8B%E5%90%84%E7%A7%8D%E6%BA%90%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/centos-repo-config/ 介绍平时在开发过程中很多时候部署环境，或者使用一些开发工具都会用到外部的源，特此记录分享； yum源配置编辑文件： 添加/etc/yum.repos.d/CentOS-inspur.repo 12345[CentOS-inspur]name=Nexus Repositorybaseurl=http://maven.inspur.com/repository/yum-public/$releasever/os/$basearch/enabled=1gpgcheck=0 执行命令： 12yum clean all yum list all pip源编辑文件： 全局的位于 /etc/pip.conf用户级别的位于 $HOME/.pip/pip.conf 123[global]trusted-host = maven.inspur.comindex-url = http://maven.inspur.com/repository/pypi-public/simple easy_install源 临时使用使用-i 参数，这个也适用于pip命令 1easy_install pip -i http://maven.inspur.com/repository/pypi-public/simple 修改配置文件修改~/.pydistutils.cfg 12[easy_install]index_url = http://maven.inspur.com/repository/pypi-public/simple npm源执行命令： 1npm config set registry http://maven.inspur.com/repository/npm-public/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>pip</tag>
        <tag>源</tag>
        <tag>配置</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装pip]]></title>
    <url>%2F2018%2F12%2F17%2FLinux%2FCentOS7-%E5%AE%89%E8%A3%85pip%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/centos7-install-pip/ 准备环境yum install gcc libffi-devel openssl-devel libxml2 libslt-devel libxml2-devel python-devel -y 安装easy_installyum install python-setuptools 安装pipeasy_install pip 如果你安装的服务器处于断网状态，需要配置内部能访问的源，可以参考各种配置源的方式]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>centos</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins中SSH remote hosts配置]]></title>
    <url>%2F2018%2F12%2F15%2F%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C%2Fjenkins%E4%B8%ADSSH-remote-hosts%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[原文 介绍今天配置自己的系统在jenkins中，能让测试人员实时的构建测试,但是在配置ssh remote hosts的时候出现了一点小问题，特此记录；使用pipeline的方式和执行shell脚本的方式很快就能搭建完成，但是本来有可以配置“构建一个maven项目”的配置为什么还要使用其他的呢，所以就采用了这种方式。但是却在最后一步出现了问题，使用ssh部署到远程服务器上的时候找不到在哪里配置remote hosts。 操作 在Jenkins主界面，系统管理-&gt;管理插件-&gt;安装SSH Plugin； 系统管理-&gt;Configure(系统设置)-&gt;SSH remote hosts 配置完成但是无法连接，测试连接粗错； 所以进行了以下操作： * 两台机执行ssh-keygen -t rsa ，生成id_rsa.pub文件 * 在jenkins linux执行命令：scp /home/xxxx/.ssh/id_rsa.pub xxxx@10.111.25.28:/home/xxxx/.ssh/authorized_keys 输入密码拷贝文件 就可以了，其实这样就可以进行不实用密码在jenkins上执行远程机器的命令： 1ssh -p 22 root@10.111.*.* "df -h" 再测试就可以连接成功了。如果中间再出现访问权限问题(Jenkins Publish over ssh authentification failed with private key)，那可以考虑一下远程机器是不是权限设置有问题，在远程机器上执行： 12chmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys 冲突解决人生不如意，十之八九，git使用过程中如果没有遇到过冲突，那绝对也是很离奇的事件。 我们平时使用git遇到冲突一般是pull代码或者push代码的时候，还有合并分支的时候。“git pull”操作等于“git fetch + git merge refs/remotes/origin/master”由此可见，git fetch更安全一点，不会合并代码。 一般解决过程： 在报错的目录下执行： git rebase remote-branch-name 先编辑冲突，然后git commit提交 执行 git add -u（-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件） git rebase –continue （重复这这些步骤，直到rebase冲突解决完成） 如果想要恢复修改bug之前的状态，执行：git rebase –abort 冲突产生后会有&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;这些内容，&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD 和=====之间的内容是我们本地的修改。 为什么会使用rebase？ git rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支，但是他们采取不同的工作流程。从上面你可以可能看到了git rebase是一个一个处理冲突的。本质上git merge会产生一个新的commit，合并的时候是全部合并，修改完成冲突就可以提交了，记录了真实的commit情况，包括每个分支的详情，但是如果频繁的使用，就会导致commit信息比较混乱。git rebase不会一次性合并，而是一个一个处理，不会有commit信息，会合并之前的commit历史，这样会让他的提交历史比较简洁，它的优点也是它的缺点，以为重写了commit历史，所以，导致提交历史不明晰。]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>远程</tag>
        <tag>ssh</tag>
        <tag>jenkins</tag>
        <tag>连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This account is currently not available问题]]></title>
    <url>%2F2018%2F12%2F15%2FLinux%2FThis-account-is-currently-not-available%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/this-account-is-currently-not-available/ 问题描述增加一个用户，并切换用户时提示错误： 1234567891011useradd limmpasswd limmsu limm# 错误信息# This account is currently not available``` # 解决办法```shellusermod -s /bin/bash limm 虽然简单，但是实用，的确困扰了自己几分钟的时间！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>解决</tag>
        <tag>用户</tag>
        <tag>无法</tag>
        <tag>切换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2018%2F12%2F13%2FGit%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/git-common-use/ 概念git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与GNU Interactive Tools（一个类似Norton Commander界面的文件管理器）有所不同。 git最初的开发动力来自于BitKeeper和Monotone。git最初只是作为一个可以被其他前端（比如Cogito或Stgit）包装的后端而开发的，但后来git内核已经成熟到可以独立地用作版本控制。很多著名的软件都使用git进行版本控制，其中包括Linux内核、X.Org服务器和OLPC内核等项目的开发流程。 Workspace：工作区（在当前仓库中，新增，更改，删除，即当前的工作空间） Index / Stage：暂存区（它实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区，这个工作区内存储了文件名、文件的状态等，这些都是存储在.git下的index文件中，文件内容存储在.git/object中，如果使用git add命令添加，将会更新到暂存区内) Repository：仓库区（或本地仓库） Remote：远程仓库 专业术语英文对照表： 仓库区和版本库、暂存库的关系： 获取代码仓库 初始化代码仓库 12345678# 创建一个代码仓库，在当前目录下$ git init# 创建代码仓库，在projectname文件夹下初始化仓库$ git init [projectname]# 从远程下载仓库并获取仓库的“所有”信息$ git clone [url] 操作文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录和子目录文件$ git add [dir]# 添加当前目录下的的所有的文件到暂存区中去$ git add .# p是patch的意思，对于同一个文件的多处变化，可以实现分次提交$ git add -p# 将工作区中的文件删除并同步删除操作到暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件的状态，但是文件还会保留在工作区，比如误提了忽略文件，再添加忽略文件的时候可以执行这个命令忽略追踪这个文件的状态，让忽略文件生效$ git rm --cached [file]# 改名工作区文件，并同步到缓存区$ git mv [file-original] [file-renamed] 提交代码123456789101112131415161718# add内容后，内容在暂存区，这个操作让暂存区内容到仓库区$ git commit -m [message]# 同上，不过指定了文件$ git commit [file1] [file2] ... -m [message]# 提交工作区与上次commit的变化，直接到仓库区$ git commit -a# 提交时后显示所有的diff信息$ git commit -v# 替换上一次的提交，包含提交信息$ git commit --amend -m [message]# 从新做一次commit，不包含提示信息$ git commit --amend [file1] [file2] ... 分支操作123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 创建一个新分支，但是还是处于当前分支，不会切换到新分支下$ git branch [branch-name]# 新建一个分支，并切换到新的分支下$ git checkout -b [branch]# 新建一个分支，指向指定分支的commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立同步的追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 将一个commit合并进当前分支$ git cherry-pick [commit]# 删除某个分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签操作1234567891011121314151617181920212223242526# 列出ta列表$ git tag# 在当前commit下创建一个tag$ git tag [tag]# 在执行commit下创建tag$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史包含commit变更的文件等$ git log --stat# 搜根据关键词搜索提交历史$ git log -S [keyword]# 显示某一个commit之后的一切变动信息$ git log [tag] HEAD --pretty=format:%s# 同上，不过提交信息必须符合过滤搜索特征$ git log [tag] HEAD --grep feature# 显示文件的版本历史$ git log --follow [file]$ git whatchanged [file]# 显示文件的一切diff$ git log -p [file]# 指定过去的几次提交，实例中为5$ git log -5 --pretty --oneline# 按照提交次序显示提交过的用户$ git shortlog -sn# 显示人对于某个文件修改的时间等$ git blame [file]# 显示暂存区和工作区的差异，这个经常会用到$ git diff# 显示暂存区和上一个提交commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 同步代码1234567891011121314151617181920212223# 下载远程仓库的所有变动,不会强制合并$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销操作12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 配置123456789# 显示当前的Git配置,user.name,user.email等等$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时包含的用户信息$ git config [--global] user.name "[name]"$ git config [--global] user.email "[email address]" 冲突解决人生不如意，十之八九，git使用过程中如果没有遇到过冲突，那绝对也是很离奇的事件。 我们平时使用git遇到冲突一般是pull代码或者push代码的时候，还有合并分支的时候。“git pull”操作等于“git fetch + git merge refs/remotes/origin/master”由此可见，git fetch更安全一点，不会合并代码。 一般解决过程： 在报错的目录下执行： git rebase remote-branch-name 先编辑冲突，然后git commit提交 执行 git add -u（-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件） git rebase –continue （重复这这些步骤，直到rebase冲突解决完成） 如果想要恢复修改bug之前的状态，执行：git rebase –abort 冲突产生后会有&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;这些内容，&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD 和=====之间的内容是我们本地的修改。 为什么会使用rebase？ git rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支，但是他们采取不同的工作流程。从上面你可以可能看到了git rebase是一个一个处理冲突的。本质上git merge会产生一个新的commit，合并的时候是全部合并，修改完成冲突就可以提交了，记录了真实的commit情况，包括每个分支的详情，但是如果频繁的使用，就会导致commit信息比较混乱。git rebase不会一次性合并，而是一个一个处理，不会有commit信息，会合并之前的commit历史，这样会让他的提交历史比较简洁，它的优点也是它的缺点，以为重写了commit历史，所以，导致提交历史不明晰。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>概念</tag>
        <tag>git</tag>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7修改防火墙配置开放端口]]></title>
    <url>%2F2018%2F12%2F12%2FLinux%2FCentOS7%E4%BF%AE%E6%94%B9%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/centos7-firewall-config/ 设置开放端口12sudo firewall-cmd --zone=public --add-port=3000/tcp --permanentsudo firewall-cmd --reload –zone #作用域–add-port=80/tcp #添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效 之后检查新的防火墙规则firewall-cmd –list-all 重启防火墙1firewall-cmd --reload 关闭防火墙12systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 常用命令firewall-cmd –state ##查看防火墙状态，是否是runningfirewall-cmd –reload ##重新载入配置，比如添加规则之后，需要执行此命令firewall-cmd –get-zones ##列出支持的zonefirewall-cmd –get-services ##列出支持的服务，在列表中的服务是放行的firewall-cmd –query-service ftp ##查看ftp服务是否支持，返回yes或者nofirewall-cmd –add-service=ftp ##临时开放ftp服务firewall-cmd –add-service=ftp –permanent ##永久开放ftp服务firewall-cmd –remove-service=ftp –permanent ##永久移除ftp服务firewall-cmd –add-port=80/tcp –permanent ##永久添加80端口iptables -L -n ##查看规则，这个命令是和iptables的相同的man firewall-cmd ##查看帮助]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos 7</tag>
        <tag>修改防火墙配置</tag>
        <tag>开发端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql连接SSL错误警告]]></title>
    <url>%2F2018%2F12%2F12%2FDB%2FMysql%E8%BF%9E%E6%8E%A5SSL%E9%94%99%E8%AF%AF%E8%AD%A6%E5%91%8A%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/mysql-ssl-errorlog/ 错误信息1WARN: Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. 什么是SSL传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。网景公司（Netscape）在1994年推出首版网页浏览器，网景导航者时，推出HTTPS协议，以SSL进行加密，这是SSL的起源。IETF将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 RFC 6176 （2011年3月）。在浏览器、邮箱、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。主要的网站，如Google、Facebook等也以这个协议来创建安全连线，发送数据。目前已成为互联网上保密通信的工业标准。SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。 以上说明内容来自于维基百科 SSL是在Web服务器和Web客户机之间建立经过身份验证和加密会话的Web协议。以首先建立TCP/IP连接的握手例行程序开始。接着，通过验证服务器的公钥为客户机验证服务器。一旦通过验证，服务器即会选择客户机和服务器都支持的并在具体的国家/地区所实施的限制内的最强密码算法。下一步将生成用来对上述客户机和服务器之间的所有数据流进行加密的共享密钥。最终，一个加密的SSL，连接便建立了。 如上所述，在客户机和服务器之间发送的所有信息都经过加密，包括所有的HTTP请求和响应以及客户机请求的URL。该级别的加密可确保信用卡号、访问授权信息(用户名)以及服务器返回的敏感数据等敏感信息的保护。 因为加密需要大量的计算，所以SSL.会话通常仅用于敏感信息的传输。 目前，美国政府允许在浏览器中使用128位加密，.从而可使银行业务和金融交易获得高度的安全性。一些产品，如Microsoft的SGC(服务器控制密码技术，属SSL，的一种扩展)，可支持这种更高水平的加密。此外，也有其他的交易安全协议存在，比如为商业交易提供较高安全等级的SET(安全电子交易)。 散列算法可创建随传送的数据发送并由接收者验证的消息摘要。签名还可以防止发送者否认该消息(否认曾发送过它)。SSL和证书 SSL依赖于数字证书。证书将公钥和公钥所属的个人、公司或服务器组合起来。认证机构(CA)颁发证书，用它们自己的私钥对证书签名，因此可对证书进行验证。 SSL要求Web服务器具有证书。当用户连接到Web服务器时，服务器向用户发送它的证书。用户可验证该证书是否真实，一旦得到证实，证书中的公钥即被用于加密，只有服务器使用其私钥才能解密的消息。 请注意，证书是“绑定”到Web站点的。换言之，证书言明它只对特定的II)地址(或地址范围)有效。使用证书的初衷是客户机必须知道它们被连接到真实的Web站点，而不是该站点的假冒者。证书将公钥与指名的实体绑定在一起。可将这同一证书绑定到特定的Web站点，这样，如果有人盗取该证书并企图建立新的Web站点时，该站点必须要有已分配给真实站点的II)地址，所以只要黑客试图这样做，就会发生错误。 问题解决在mysql连接字符串url中加入ssl=true或者false即可： 1jdbc:mysql://127.0.0.1:3306/service-server?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false 如果使用ssl=true的话需要一系列的操作生成密钥，修改配置，开启ssl，创建用户等等，大家有需要的话可以自行操作一下。]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>警告</tag>
        <tag>ssl</tag>
        <tag>解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统Mysql数据库安装及修改存储数据位置]]></title>
    <url>%2F2018%2F12%2F11%2FDB%2FLinux%E7%B3%BB%E7%BB%9FMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BF%AE%E6%94%B9%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[原文:http://limingming.org/index.php/2018/12/linux-mysql-install-config/ 介绍本文介绍在centos7.2下安装mysql 5.7.13 安装 下载rpm包 1wget http://repo.mysql.com//mysql57-community-release-el7-8.noarch.rpm 安装yum Repository： 1yum -y install mysql57-community-release-el7-8.noarch.rpm 安装MySQL服务端： 1yum -y install mysql-community-server.x86_64 启动mysql服务： 1systemctl start mysqld.service 重置密码 1$ mysql -u root 出了如下错误ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO)查看一下/etc/my.cnf,如果你没有改配置的话应该在log-error=/var/log/mysqld.log：1vi /var/log/mysqld.log 从内容中找到“ A temporary password is generated for root@localhost: Gj.,i:o9iRgQ”；Gj.,i:o9iRgQ就是数据库密码； 12mysql -u root -p&gt;Gj.,i:o9iRgQ 登录成功了，之后使用如下出现错误： mysql&gt; show databases;ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.这里是因为密码不符合规则，这个与validate_password_policy的值有关。 执行： 1alter user 'root'@'localhost' identified by 'root123456'; 现在就安装成功了； 修改配置mysql数据库存储的数据逐渐变大，数据增多到原有磁盘无法容纳的情况，所以要对数据进行迁移。在安装完成数据库后最好能讲数据放到磁盘存储大的地方。 停止mysql 1systemctl stop mysqld 创建新的数据存放目录 1mkdir /home/mysql 将数据移动到新的目录如果忘记原来存储的目录可以查看/etc/my.cnf中的datadir=？ 1mv /var/lib/mysql/* /home/mysql/ 还涉及到一些问题，innoDB引擎和MyISAM引擎的数据文件是不一样的，比如MyISAM引擎, 数据文件以”.frm”，”.MYD”，”*.MYI”三个文件存储于”/var/lib/mysql”目录下的对应数据库文件夹中，直接将这些文件移动到新的目录中即可 针对innoDB引擎，数据则存储在”$innodb_data_home_dir” 的ibdata1文件中(一般情况下是这样的)，结构文件存在于table_name.frm中。 修改mysql数据库目录文件权限 1chown mysql:mysql -R /data/mysql/ 修改socket1234vi /etc/my.cnf # 修改内容 socket=/home/mysql/mysql.sockdatadir=/home/mysql/ vi /etc/init.d/mysqld12# 添加内容datadir=/home/mysql/ 创建一个连接文件到/var/lib/mysql/mysql.sock 1ln -s /home/mysql/mysql.sock /var/lib/mysql/mysql.sock 重启mysql服务执行 :1systemctl start mysqld 但是无法启动；报错信息：1Job for mysqld.service failed because the control process exited with error code. See &quot;systemctl status mysqld.service&quot; and &quot;journalctl -xe&quot; for details. 看到报错，第一时间想到的是查看一下日志信息，如果忘记日志文件位置，可以查看一下/etc/my.cnf ,log-error=/var/log/mysqld.log; 截取报错信息如下： 12345672018-12-11T08:29:12.795857Z 0 [ERROR] InnoDB: The innodb_system data file &apos;ibdata1&apos; must be writable2018-12-11T08:29:12.795878Z 0 [ERROR] InnoDB: The innodb_system data file &apos;ibdata1&apos; must be writable2018-12-11T08:29:12.795885Z 0 [ERROR] InnoDB: Plugin initialization aborted with error Generic error2018-12-11T08:29:13.396561Z 0 [ERROR] Plugin &apos;InnoDB&apos; init function returned error.2018-12-11T08:29:13.396603Z 0 [ERROR] Plugin &apos;InnoDB&apos; registration as a STORAGE ENGINE failed.2018-12-11T08:29:13.396608Z 0 [ERROR] Failed to initialize builtin plugins.2018-12-11T08:29:13.396611Z 0 [ERROR] Aborting 看到这个must be writable，第一时间想到的是权限问题，所以执行了以下权限命令： 12chown -R mysql:mysql /home/mysql chmod 777 -R /home/mysql 重新启动不行，所以用命令getenforce，查看了一下selinux，修改selinux：1vi /etc/sysconfig/selinux 将SELINUX=enforcing 改为 SELINUX=permissive； 又重新启动发现还是不行，才意识到，如果一个文件是在selinux打开的时候创建的，那么即使你关闭selinux，它的权限控制还是会起作用的。可以通过chcon来改变权限； 因为我的机子没有其他应用，所以我选择了重启,重启之后就可以了 PS： 所以说如果你想要试试的话最好安装mysql前关闭selinux！！！]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>解决</tag>
        <tag>安装</tag>
        <tag>迁移</tag>
        <tag>数据</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过yum安装Ansible]]></title>
    <url>%2F2018%2F12%2F10%2FLinux%2F%E9%80%9A%E8%BF%87yum%E5%AE%89%E8%A3%85Ansible%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/yum-install-ansible/ 介绍Fedora 用户可直接安装Ansible, 但RHEL或CentOS用户,需要 配置 EPEL yum安装我的是CentOS7.2: 1234567# 建议执行，如果没有subscription-manager命令先安装subscription-manager repos --enable "rhel-*-optional-rpms" --enable "rhel-*-extras-rpms"yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# install the epel-release RPM if needed on CentOS, RHEL, or Scientific Linux$ sudo yum install ansible 创建rpm包使用 make rpm 命令创建RPM软件包. 然后可分发这个软件包或是使用它来安装Ansible.在创建之前,先确定你已安装了 rpm-build, make, and python2-devel . 12345$ yum -y install rpm-build make python2-devel$ git clone git://github.com/ansible/ansible.git$ cd ./ansible$ make rpm$ sudo rpm -Uvh ~/rpmbuild/ansible-*.noarch.rpm 补充可能你会选择用pip安装12pip install ansible --upgrade --no-index --find-links=http://10.111.24.89:81/httpfiles/pipfiles/ --trusted-host 10.111.24.89 安装过程中可能会出现： Command “python setup.py egg_info” failed with error code 1 in /tmp/pip-install-soDkws/ansible/ 解决： 1pip install --upgrade setuptools 重新安装就可以了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>yum</tag>
        <tag>ansible</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 数据库修改密码及更改远程访问权限]]></title>
    <url>%2F2018%2F12%2F08%2FDB%2Fmysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E5%8F%8A%E6%9B%B4%E6%94%B9%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/mysql-change-passwd-and-grant/ mysql修改密码 方式一 1set password for 'user_name'@'host_name'=password('new_pwd') 方式二使用update系统表方式 123use mysql;update user set password=password('passwd') where user='user_name';flush privileges; 补充：对于user表password类，如果不用password函数的话，导致更新后无法登陆。 也可以在用户创建后直接使用grant方式来更新用户密码 1grant usage on *.* to '用户名'@'localhost' identified by '密码'; 忘记mysql密码重制密码过程 123456789101112131415161718192021222324# 停止mysql服务 service mysql stop # 使用--skip-grant-tables选项跳过授权表验证 #获取mysqld帮助信息mysqld --help --verbose --skip-grant-tables# 使用--skip-grant-tables启动mysql服务器mysqld --skip-grant-tables --user=mysql &amp;ps -ef | grep mysqlmysql select user,host,password from mysql.user where user='root'; --更新mysql账户密码为NULL或设定为新密码，注设定为空密码时可以直接设置update mysql.user set password='' where user='root';select user,host,password from mysql.user where user='root';exit# 再次停止mysql数据库服务器service mysql stopservice mysql startmysql #重启后再次登陆，不再需要任何密码 设置允许远程连接 开启远程访问 12grant all privileges on *.* to 'root'@'%' identified by 'password';flush privileges; 命令语句中第一个*代表数据库，可以改成允许访问的数据库名称 命令中第二个 是数据库的表名称，代表允许访问任意的表 root代表远程登录使用的用户名，可以自定义 %代表允许任意ip登录，如果你想指定特定的IP，可以把%替换成具体的IP就可以了 password代表远程登录时使用的密码，可以自定义 flush privileges;这是让权限立即生效 修改配置文件my.cnf是mysql的配置文件，路径是/etc/my.cnf如果寻找文件寻找不到的话，可以用linux搜索的命令 1find /* -name my.cnf 通过vim编辑该文件，找到bind-address = 127.0.0.1这一句，然后在前面加个#号注释掉，保存退出然后重新启动服务。 1service mysql restart 在终端输入：mysql -h 服务器ip地址 -P 3306 -u root -p 如果可以访问就证明成功了，如果还不可以，查看一下防火墙，开发3306端口。可以参考CentOS7修改防火墙配置开放端口]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>修改</tag>
        <tag>密码</tag>
        <tag>设置</tag>
        <tag>远程</tag>
        <tag>访问</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nexus3配置yum源]]></title>
    <url>%2F2018%2F12%2F08%2FLinux%2Fnexus3%E9%85%8D%E7%BD%AEyum%E6%BA%90%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/nexus3-yum-repo/ 使用在生产环境中，或者在隔离外网的服务器环境中，不能在线更新下载RPM包，所以借助有一台Linux服务器可以连接外网，剩余的服务器通过这台YUM服务器更新就可以了。 开篇以前的做法是先把包下载到内网中的YUM服务器上，然后通过createrepo命令生成本地仓库，其余服务器通过HTTP访问这个链接，这种方式比较费时费力，而且工作效率不高，在这也简要的把这种方式介绍一下，这种方式下一般应用到本地为开发环境可以联网但是开发环境并不可以的情况，如果是简单部署单个应用不是很多应用的话，这种方式还是有可取之处的。 开发环境下： 12345yum install createrepo -yyum install -y createrepo --downloadonly --downloaddir=/root/rpmcache/Packagesrm -rf /root/rpmcache/repodata/cd /root/rpmcache &amp;&amp; createrepo . 详细的每一个命令就不一一介绍了，执行完成这些这样开发环境下我们就准备好了相关的依赖。 生产环境我们将/root/rpmcache 复制到到生产环境下 123456vi /etc/yum.repos/aaa.repo# 写入以下内容，files为路径[aaa]baseurl = files:///root/rpmcachegpgcheck = 0name = aaa 执行123yum clean allyum repolist 这样就可以使用了。 配置Nexus当然neuxs的方式更通用一些，将nexus放到能链接外网的服务器上，通过nexus暴露服务就可以了。 使用浏览器打开neuxs的网站，输入管理员密码 点击配置-&gt;Repositories-&gt;选择类型（yum proxy） 自定义一个名字，例如：yum-proxy 输入URL: http://mirrors.163.com/centos/centos可以用http://mirror.centos.org/centos/ ，可以参考yum源地址创建完成后得到源的私服地址,如果有必要的话，把用到的源统一通过group的方式暴露出来就可以了。 配置使用因为服务器无法链接内网可以将/etc/yum.repos.d/下的repo文件备份，如果有必要恢复的话，例如CentOS-Base.repo 等在/etc/yum.repos.d/下创建neuxs.repo文件写入： 123456# cat nexus.repo[nexus]name=Nexus Repositorybaseurl=http://IP:8081/repository/yum-proxy/$releasever/os/$basearch/enabled=1gpgcheck=0 在你的nexus服务URL后要加上“$releasever/os/$basearch/”执行12yum clean allyum list all 接下来就可以使用配置的yum源了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>源</tag>
        <tag>配置</tag>
        <tag>yum</tag>
        <tag>nexus3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国内yum源地址]]></title>
    <url>%2F2018%2F12%2F07%2FLinux%2F%E5%9B%BD%E5%86%85yum%E6%BA%90%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/yum-repo-china/ 最近公司内服务器迁移，需要配置一些能代理外网的yum源地址，以下是一些yum源的总结： 企业阿里云：https://opsx.alibaba.com/mirror搜狐开源镜像站：http://mirrors.sohu.com/ 网易开源镜像站：http://mirrors.163.com/ 大学 北京理工大学 http://mirror.bit.edu.cn (IPv4 only)http://mirror.bit6.edu.cn (IPv6 only) 北京交通大学 http://mirror.bjtu.edu.cn (IPv4 only)http://mirror6.bjtu.edu.cn (IPv6 only)http://debian.bjtu.edu.cn (IPv4+IPv6) 兰州大学 http://mirror.lzu.edu.cn/ 厦门大学http://mirrors.xmu.edu.cn/ 清华大学 http://mirrors.tuna.tsinghua.edu.cn/ (IPv4+IPv6)http://mirrors.6.tuna.tsinghua.edu.cn/ (IPv6 only)http://mirrors.4.tuna.tsinghua.edu.cn/ (IPv4 only) 天津大学 http://mirror.tju.edu.cn/ 中国科学技术大学http://mirrors.ustc.edu.cn/ (IPv4+IPv6)http://mirrors4.ustc.edu.cn/http://mirrors6.ustc.edu.cn/ 东北大学 http://mirror.neu.edu.cn/ (IPv4 only)http://mirror.neu6.edu.cn/ (IPv6 only) 电子科技大学 http://ubuntu.uestc.edu.cn/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>仓库</tag>
        <tag>源</tag>
        <tag>yum</tag>
        <tag>国内</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac上安装部署nginx]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C%2Fmac%E4%B8%8A%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2nginx%2F</url>
    <content type="text"><![CDATA[原文 介绍Nginx（发音同engine x）是异步框架的 Web服务器，也可以用作反向代理，负载平衡器 和 HTTP缓存。该软件由 Igor Sysoev 创建，并于2004年首次公开发布。同名公司成立于2011年，以提供支持。Nginx是免费的开源软件，根据类BSD许可证的条款发布。一大部分Web服务器使用Nginx,通常作为负载均衡器。 –维基百科 环境搭建 打开终端,安装brew 1usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装成功后，使用查看版本，验证是否安装成功1brew -v 安装ngnix 1brew install nginx 我安装完成的版本是：12$ nginx -vnginx version: nginx/1.15.6 中间安装过程中可能会出现warning,为了不必要的麻烦执行以下安装命令 1sudo xcode-select --install 会出现如下提示安装的工具，稍等几分钟就安装成功了。 启动关闭nginx 启动nginx123brew services start nginx# 或者更常用的：nginx 使用浏览器访问http://localhost:8080 ，应该可以看到 wlecom to nginx 的欢迎界面。 关闭命令：nginx -s quit 或者： 1234$ ps -ef | grep nginx 502 82708 1 0 6:22下午 ?? 0:00.02 nginx: master process /usr/local/opt/nginx/bin/nginx -g daemon off; 502 82709 82708 0 6:22下午 ?? 0:00.00 nginx: worker process 502 82712 82200 0 6:22下午 ttys000 0:00.00 grep nginx 找到它的进程号 82708 ，杀死！ 1kill -QUIT 82708 kill -QUIT 15800 (慢慢停止，不会立刻停止)Kill -TERM 15800 （立刻停止）Kill -INT 15800 （和上面一样，也是立刻停止） 重启 12cd /usr/local/Cellar/nginx/1.15.6/bin./nexus reload nexus 各个参数 123456789101112131415./nginx -hnginx version: nginx/1.15.6Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /usr/local/Cellar/nginx/1.15.6/) -c filename : set configuration file (default: /usr/local/etc/nginx/nginx.conf) -g directives : set global directives out of configuration file 大家可以根据自己的需要执相应的命令. 补充&amp;强调 nginx安装文件目录 /usr/local/Cellar/nginx nginx配置文件目录/usr/local/etc/nginx config文件目录/usr/local/etc/nginx/nginx.conf 系统hosts位置/private/etc/hosts nginx常用命令 12345nginx #启动nginxnginx -V #查看版本，以及配置文件地址nginx -v #查看版本nginx -s reload|reopen|stop|quit #重新加载配置|重启|快速停止|安全关闭nginxnginx -h #帮助 卸载nginx1brew uninstall nginx]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>部署</tag>
        <tag>mac</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven仓库存在jar包但依旧提示无法下载]]></title>
    <url>%2F2018%2F12%2F05%2FMaven%2FMaven%E4%BB%93%E5%BA%93%E5%AD%98%E5%9C%A8jar%E5%8C%85%E4%BD%86%E4%BE%9D%E6%97%A7%E6%8F%90%E7%A4%BA%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/maven-has-jar-but-downloading/ 介绍最近服务器的迁移，把原来服务器的地址都更改了，所以私服的地址也改动了，原来项目下载到本地仓库的包，但是重新构建过程中竟然发现依然要提示下载，本地仓库里面明明有包，为什么还要下载？ 解决去maven仓库包下面你会发现有_remote.repositories文件，下载不下来问题就是因为这个文件导致的。你可能会发现nexus=的信息在这个文件中，这个文件中已经连接不上原来的nexus私服了，所有会报错依然会生成lastUpdatedw文件，如果你可以从新的服务地址中下载，你可以选择删除掉这个包，重新下载，如果不能的话可以选择改掉nexus=的信息，改成可以连接的地址，那它就不会重新下载了，例如改成 central=，这代表从远程中央仓库下载。 结果最后当然会成功，如果不成功的话重新检查一下网络情况！]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>存在</tag>
        <tag>依然</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github删除仓库]]></title>
    <url>%2F2018%2F12%2F04%2FGit%2Fgithub%E5%88%A0%E9%99%A4%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/how-to-delete-repo-in-github/ 介绍这片记录来自于好几年前自己在其他平台上写的博客，简单到只有几个步骤，但是因为删除github的仓库我的确找了好一会才找到怎么去删除，谨以此文献给还没有找到怎么删除仓库的程序员和非程序员. 进入你要删除的仓库 点击settings 找到删除仓库 输入你要删除仓库的名字 你就和你原来的仓库拜拜了 文章太短，图片来凑 提交代码我发布了如何删除github仓库的博客之后发现竟然有小姐姐留言说如果仓库是空的怎么删除，看来是刚创建了一个仓库删除不了空的仓库了，如果你不想在网页上创建一个文件上传的话，那就使用命令提交代码 清空缓存有些时候很多人误提交了忽略文件，当再次添加忽略文件内容进行忽略的时候不起左右，建议重新执行以下代码清空缓存区操作 1git rm -r --cached . 添加要提交的文件如果要全部提交的话可以使用 . 如果是某个文件可以单独添加声明具体文件 123git add .git commit -m "chore: 提交注释内容"git push 当然最好你添加了ssh密钥 文章太短，图片来凑]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>删除</tag>
        <tag>仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven工具包目录介绍]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2Fmaven%E5%B7%A5%E5%85%B7%E5%8C%85%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[maven的安装目录结构如下：12345678910111213binbootconflibLICENSE.txtNOTICE.txtREADME.txt 介绍 Bin 该目录包含了mvn运行的脚本，这些脚本用来配置Java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。其中mvn是基于UNIX平台的shell脚本，mvn.bat是基于Windows平台的bat脚本。在命令行输入任何一条mvn命令时，实际上就是在调用这些脚本。该目录还包含了mvnDebug和mvnDebug.bat两个文件，同样，前者是UNIX平台的shell脚本，后者是windows的bat脚本。那么mvn和mvnDebug有什么区别和关系呢？打开文件我们就可以看到，两者基本是一样的，只是mvnDebug多了一条MAVEN_DEBUG_OPTS配置，作用就是在运行Maven时开启debug，以便调试Maven本身。此外，该目录还包含m2.conf文件，这是classworlds的配置文件。 Boot 该目录只包含一个文件，以maven 3.0为例，该文件为plexus-classworlds-2.2.3.jar。plexus-classworlds是一个类加载器框架，相对于默认的java类加载器，它提供了更丰富的语法以方便配置，Maven使用该框架加载自己的类库。更多关于classworlds的信息请参考http://classworlds.codehaus.org/。对于一般的Maven用户来说，不必关心该文件。 Conf该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为。一般情况下，我们更偏向于复制该文件至~/.m2/目录下（这里~表示用户目录），然后修改该文件，在用户范围定制Maven的行为。 Lib 该目录包含了所有Maven运行时需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如mavn-core-3.0.jar、maven-model-3.0.jar之类的文件，此外这里还包含一些Maven用到的第三方依赖如common-cli-1.2.jar、google-collection-1.0.jar等等。可以说，这个lib目录就是真正的Maven。关于该文件，还有一点值得一提的是，用户可以在这个目录中找到Maven内置的超级POM， 其他： LICENSE.txt记录了Maven使用的软件许可证Apache License Version 2.0； NOTICE.txt记录了Maven包含的第三方软件；而README.txt则包含了Maven的简要介绍，包括安装需求及如何安装的简要指令等等。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>工具包</tag>
        <tag>目录</tag>
        <tag>介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven核心概念]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2FMaven%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/03/maven-life-and-others/ 介绍Maven作为一个构建工具由于遵循了约定优于配置的原则，只要编写比Ant所需少得多的脚本就能实现同样的构建。并且Maven还有很多Ant没有的高级特性，例如依赖管理等，这一切使得Maven不仅是构建工具，更是项目管理工具，并越发流行起来。 Maven拥有三套相互独立的生命周期，它们分别为clean，default和site。 Clean Lifecycle在进行真正的构建之前进行一些清理工作。Default Lifecycle构建的核心部分，编译，测试，打包，部署等等。Site Lifecycle生成项目报告，站点，发布站点。每个生命周期包含一些阶段，这些阶段是有顺序的，并且后面的阶段依赖于前面的阶段，用户和Maven最直接的交互方式就是调用这些生命周期阶段。较之于生命周期阶段的前后依赖关系，三套生命周期本身是相互独立的，用户可以仅仅调用clean生命周期的某个阶段，或者仅仅调用default生命周期的某个阶段，而不会对其他生命周期产生任何影响。 以下是我列出的百度百科中对maven的使用介绍，可见maven的使用是很简单的： 1234567891011121314151617181920212223mvn archetype:create创建Maven项目mvn compile编译源代码mvn deploy发布项目mvn test-compile编译测试源代码mvn test运行应用程序中的单元测试mvn site生成项目相关信息的网站mvn clean清除项目目录中的生成结果mvn package根据项目生成的jarmvn install在本地Repository中安装jarmvn eclipse:eclipse生成eclipse项目文件mvn jetty:run启动jetty服务mvn tomcat:run启动tomcat服务 正因为我们使用maven的方便，这导致了开发人员只是单纯的使用几个命令，而对Maven不求详细的了解，上述命令中有些有冒号，而有些没有，有冒号的命令是执行指定的插件，而没有冒号的命令是执行按照Maven生命周期里来执行的。那究竟生命周期又是什么呢？ 生命周期Maven的生命周期是对所有的构建过程进行抽象和统一。Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际的工作，生命周期只是定义了一系列的阶段，并确定这些阶段的执行顺序。而在执行这些阶段时，实际的工作还是由插件来完成的。 上面我们也说到过，生命周期包含一些阶段，这些阶段是有顺序的，并且后面的阶段依赖于前面的阶段，用户和Maven最直接的交互方式就是调用这些生命周期阶段。 clean生命周期 clean生命周期的目的是清理项目，它包含三个阶段： 1）pre-clean 执行一些清理前需要完成的工作。 2）clean 清理上一次构建生成的文件。 3）post-clean 执行一些清理后需要完成的工作。 default生命周期 default生命周期定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分，它包含的阶段如下： 1） validate 验证项目是否正确和所有需要的相关资源是否可用 2） initialize 初始化构建 3） generate-sources 4) process-sources 处理源代码 5） generate-resources 6) process-resources 处理项目主资源文件。对src/main/resources目录的内容进行变量替换等工作后，复制到项目输出的主classpath目录中。 7） compile 编译项目的主源代码 8） process-classes 9) generate-test-sources 10) process-test-sources 处理项目测试资源文件 11）generate-test-resources 12) process-test-resources 处理测试的资源文件 13）test-compile 编译项目的测试代码 14）process-test-classes 15) test 使用单元测试框架运行测试，测试代码不会被打包或部署 16）prepare-package 做好打包的准备 17）package 接受编译好的代码，打包成可发布的格式 18) pre-integration-test 19) integration-test 20) postintegration-test 21) verify 22) install 将包安装到Maven本地仓库，供本地其他Maven项目使用 23）deploy 将最终的包复制到远程仓库，供其他开发人员和Maven项目使用 site生命周期 site生命周期的目的是建立和发布项目站点，Maven能够基于POM所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。该生命周期包含如下阶段： 1）pre-site 执行一些在生成项目站点之前需要完成的工作 2）site 生成项目站点文档 3）post-site 执行一些在生成项目站点之后需要完成的工作 4）site-deploy 将生成的项目站点发布到服务器上 用户在mvn命令后可以指定三个生命周期中的任何阶段，则Maven会按以下逻辑执行：首先会得到该阶段所属生命周期，从该生命周期中的第一个阶段开始按顺序执行，直至该阶段本身。例如执行mvnclean命令会依次执行clean生命周期中的pre-clean阶段及clean阶段。mvn命令后可以指定多个阶段，Maven会按照输入的顺序依次执行，每次执行都会按照之前描述的逻辑执行 projectobject Modelpom是一个xml，是maven工作的基础，执行任务时，maven会到项目根目录下读取pom.xml获得需要的配置信息pom文件中包含了项目的信息和maven build项目所需的配置信息，通常有项目信息(如版本、成员)、项目的依赖、插件和goal、build选项等等pom是可以继承的，通常对于一个大型的项目或是多个module的情况，子模块的pom需要指定父模块的pom Artifact &amp; RepositoriesArtifact：一个项目将要产生的文件，可以是jar文件，源文件，二进制文件，war文件，甚至是pomRepositories是用来存储Artifact的Repositories分为本地仓库和远程仓库，远程仓库是指远程服务器上用于存储Artifact的仓库，本地仓库是指本机存储Artifact的仓库 Maven坐标Maven坐标是一组可以惟一标识构件的三元组值groupId，代表构件的实体或组织例如：org.inspur.loushangartifactId,实际的构件的名称，例如frameworkversion，该构件件的版本号packaging ：定义Maven项目打包的方式，首先，打包方式通常与所生成构件的文件扩展名对应，如上例中的packaging为jar,最终的文件名为my-app-0.0.1-SNAPSHOT.jar。也可以打包成war, ear等。当不定义packaging的时候，Maven 会使用默认值jar classifier: 该元素用来帮助定义构建输出的一些附件。附属构件与主构件对应，如上例中的主构件为my-app-0.0.1-SNAPSHOT.jar,该项目可能还会通过一些插件生成如my-app-0.0.1-SNAPSHOT-javadoc.jar,my-app-0.0.1-SNAPSHOT-sources.jar, 这样附属构件也就拥有了自己唯一的坐标]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>概念</tag>
        <tag>核心</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven配置使用nexus私服]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2FMaven%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8nexus%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[[原文：http://limingming.org/index.php/2018/12/03/maven-use-nexus/](http://limingming.org/index.php/2018/12/03/maven-use-nexus/） 在项目中的pom中：123456789101112131415&lt;!-- 配置私服使用信息 --&gt;&lt;repositories&gt;&lt;repository&gt;&lt;id&gt;nexus-jar&lt;/id&gt;&lt;name&gt;Team Nexus jar Repository&lt;/name&gt;&lt;url&gt;http://IP:host/nexus/content/groups/inspur-loushang/&lt;/url&gt;&lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt;&lt;pluginRepository&gt;&lt;id&gt;nexus-plugin&lt;/id&gt;&lt;name&gt;Team Nexus plugin Repository&lt;/name&gt;&lt;url&gt;http://IP:host/nexus/content/groups/inspur-loushang/&lt;/url&gt;&lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 在setting.xml中（1）在mirrors中配置唯一镜像： 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;jszx&lt;/name&gt; &lt;url&gt;http://IP:host/nexus/content/groups/inspur-jszx/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; （2）在profiles中配置 12345678910111213141516171819202122232425262728293031&lt;profiles&gt;&lt;!-- 添加私服配置 --&gt; &lt;profile&gt; &lt;id&gt;myprofile&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://IP:host/nexus/content/groups/inspur-jszx/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://IP:host/nexus/content/groups/inspur-jszx/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; 在profiles外添加激活配置： 123&lt;activeProfiles&gt; &lt;activeProfile&gt;myprofile&lt;/activeProfile&gt; &lt;/activeProfiles&gt; activeProfile可以有多个.]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>maven</tag>
        <tag>使用私服</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装nexus]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2F%E5%AE%89%E8%A3%85nexus%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/03/maven-install-nexus/ 介绍私服不是Maven的核心概念，它仅仅是一种衍生出来的特殊的Maven仓库。如果没有私服，我们所需的所有构件都需要通过maven的中央仓库和第三方的Maven仓库下载到本地，而一个团队中的所有人都重复的从maven仓库下载构件无疑加大了仓库的负载和浪费了外网带宽，如果网速慢的话，还会影响项目的进程。很多情况下项目的开发都是在内网进行的，连接不到maven仓库怎么办呢？开发的公共构件怎么让其它项目使用？这个时候我们不得不为自己的团队搭建属于自己的maven私服，这样既节省了网络带宽也会加速项目搭建的进程，当然前提条件就是你的私服中拥有项目所需的所有构件。 安装NexusNexus是典型的JavaWeb应用，它有两种安装包，一种是包含Jetty容器的Bundle包，另一种是不包含Web容器的war包。 下载Nexus 官网http://www.sonatype.org/nexus/ 下载最新的Nexus。 Bundle方式安装Nexus a.首先看下解压后的目录，结构： 解压后存在两个文件夹：nexus-2.4.0-01（不同版本版本号不同）和sonatype-work。 nexus-2.4.0-01: 该目录包含了Nexus运行所需要的文件，如启动脚本、依赖jar包等。 sonatype-work：该目录包含Nenus生成的配置文件、日志文件、仓库文件等。 第一个目录是运行Nexus必须的，而第二个不是必须的，Nexus会在运行的时候动态创建该目录。 b.配置Path，启动Nexus（在windows操作系统上） 首先在环境变量path下加入如下地址：C:\nexus\nexus-2.6.2-01-bundle\nexus-2.6.2-01\bin；之后在cmd下启动Nexus服务： 启动成功后，可以打开打开浏览器访问：http://localhost:8081/nexus 就可以看到Nexus的界面了。 8081为默认的端口号，要修改端口号可进入nexus-2.1.2-bundle\nexus-2.1.2\conf\打开nexus.properties文件，修改application-port属性值就可以了 这时你可以单击界面右上角的Login进行登录，Nexus默认管理用户名和密码为admin/admin123。 b.1在linux上切换到/opt/nexus/nexus-2.14.0-01/bin目录下 存在nexus及nexus.bat文件，可以使用./nexus start 启动nexus，这时候可能会报错。 这时候提示： 123WARNING – NOTRECOMMENDED TO RUN AS ROOTIf you insist running as root, then set theenvironment variable RUN_AS_USER=root before running this script. 大概意思就是要在环境配置export RUN_AS_USER=root，临时配置 在命令行下输入： 1export RUN_AS_USER=root 然后执行，就不会再提示了 1./nexus start 也可以在系统里面永久配置 1vi /etc/profile 加入export RUN_AS_USER=root Nexus的索引这时你使用Nexus搜索插件得不到任何结果，为了能够搜索Maven中央库，首先需要设置Nexus中的MavenCentral仓库下载远程索引。 单击左边导航栏的Repositories，可以link到这个页面，选择Central，点击Configuration，里面有一个DownloadRemote Indexes配置，默认状态是false，将其改为true，‘Save’后，单击Administration==&gt; ScheduledTasks,就有一条更新Index的任务，这个是Nexus在后天运行了一个任务来下载中央仓库的索引。由于中央仓库的内容比较多，因此其索引文件比较大，Nexus下载该文件也需要比较长的时间。请读者耐心等待把。如果网速不好的话，可以使用其他人搭建好的的Nexus私服。后面会介绍 配置Maven从Nexus下载构件 在POM中配置Nexus私服，这样的配置只对当前的Maven项目有效。 12345678910111213&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Repository&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 在settings.xml中配置profile元素，这样就能让本机所有的Maven项目都使用自己的Maven私服。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt;&lt;/profiles&gt;``` 以上配置所有Maven下载请求都仅仅通过Nexus，以全面发挥私服的作用。# 部署构件到Nexus1. 在POM中配置```xml&lt;project&gt; ... &lt;distributionManagement&gt;&lt;snapshotRepository&gt; &lt;id&gt;user-snapshots&lt;/id&gt; &lt;name&gt;User Project SNAPSHOTS&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/MyUserReposSnapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;repository&gt; &lt;id&gt;user-releases&lt;/id&gt; &lt;name&gt;User Project Release&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/MyUserReposRelease/&lt;/url&gt; &lt;/repository&gt; &lt;/distributionManagement&gt; ...&lt;/project&gt; settings.xml中配置认证信息，Nexus的仓库对于匿名用户是只读的。 123456789101112131415&lt;servers&gt; &lt;server&gt; &lt;id&gt;user-snapshots&lt;/id&gt; &lt;username&gt;lb&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;user-releases&lt;/id&gt; &lt;username&gt;lb&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>maven</tag>
        <tag>nexus</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍maven私服-Nexus]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2F%E4%BB%8B%E7%BB%8Dmaven%E7%A7%81%E6%9C%8D-Nexus%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/03/maven-nexus-2/ 什么是私服私服是架设在局域网的一种特殊的远程仓库，目的是代理远程仓库及部署第三方构件。有了私服之后，当Maven 需要下载构件时，直接请求私服，私服上存在则下载到本地仓库；否则，私服请求外部的远程仓库，将构件下载到私服，再提供给本地仓库下载。 以下是有无私服的对比： Nexus下载与安装 Nexus安装的先决条件不管是NexusOpen Source还是Nexus Professional，他们只有一个先决条件就是必须有一个JavaRuntime Environment，且必须是Java 5或更高。 下载Nexus：Nexus有2个版本，Nexus Open Source 和 NexusProfessional。NexusOpen Source是可基于EPL协议免费使用修改分发的全功能仓库管理系统。Nexus Professional主要用于需要复杂大型企业或组织。 本文只介绍NexusOpen Source，下文简称Nexus。Nexus下载地址，有完整版，有war版。前者可以单独运行为一个基于jetty的服务，后者是运行在ServletConstainer的Web应用。 安装Nexus安装Nexus非常简单。解压下载的文件到任意目录，不过要小心权限问题已经Windows下带空格文件夹引起的问题。然后配置NEXUS_HOME。解压出来的目录下除了nexus外，还有一个sonatype-work文件夹。这个文件夹包含了所有nexus的仓库以及配置数据，这么做使得更加容易更新到新版的nexus。当然，这个目录的路径也能通过NEXUS_HOME/conf/nexus.properties修改。 运行Nexus当你运行Nexus时，你实际运行的是一个运行在0.0.0.0:8081的web server。Nexus运行在一个Jetty的servlet容器内，然后通过一个本地的封装服务Tanuki Java Service Wrapper来启动。它可以通过配置将nexus运行为一个unix或者windows的一个服务。bin目录下的nexus或者nexus.bat就是服务的起点，通过你的系统来选择对应的版本。 启动后，你就能通过浏览器访问http://localhost:8081/nexus 配置Nexus为服务 当你把Nexus用于生产环境时，你应该将Nexus配置为一个服务，让他在后台运行以及在服务器重启后恢复服务。方法是 bin/nexus start 常用功能Nexus常用功能就是：指定私服的中央地址、将自己的Maven项目指定到私服地址、从私服下载中央库的项目索引、从私服仓库下载依赖组件、将第三方项目jar上传到私服供其他项目组使用。开启Nexus服务后访问url地址http://localhost:8081/nexus, (推荐使用自己的ip地址)，之后登录系统，用户名密码分别是：admin/admin123. 仓库类别：Hosted代表宿主仓库，用来发布一些第三方不允许的组件，其中自带仓库类型中3rd一般用来发布第三方无法在中央仓库获取的jar包，比如oracle的jdbc的jar包，Releases一般存放公司内的封版的项目，Snapshots用来存放正在开发的版本。Proxy代表代理远程的仓库，最典型的就是Maven官方中央仓库、JBoss仓库等等。如果构建的Maven项目本地仓库没有依赖包，那么就会去这个代理站点去下载，那么如果代理站点也没有此依赖包，就回去远程中央仓库下载依赖，这些中央仓库就是proxy。代理站点下载成功后再下载至本机。笔者认为，其实Maven这个自带的默认仓库一般情况下已经够大多数项目使用了。group 仓库是一个“仓库组”，为开发人员便于开发设置的仓库，可以将多个已存在的其他仓库配置其中提供给大家使用，在nexus中配置的时候注意的是左侧是配置仓库组使用的仓库。virtual仓库是用于提供中央仓库中M1格式的发布版本的构件镜像仓库，即在当此M2仓库中为M1格式的仓库构件缓存提供出来的。 maven项目索引: 下载Maven项目索引，项目索引是为了使用者能够在私服站点查找依赖使用的功能例如：就可以检索出它的相关信息，包括怎么配置依赖信息。我们要想使用这个私服仓库，先在项目pom中配置相关私服信息 使用配置以下为在pom中声明指定使用私服的方式： 指定仓库 12345678910111213&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;nexus&lt;/name&gt; &lt;url&gt;http://192.168.1.103:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 指定插件仓库 12345678910111213&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;nexus&lt;/name&gt; &lt;url&gt;http://192.168.1.103:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; 这样只有本项目才在私服下载组件 这样这个Maven项目构建的时候会从私服下载相关依赖，当构建项目的时候，maven会从私服将构件下载到本地仓库，当然这个配置仅仅是在此项目中生效，对于其他项目还是不起作用。如果相对Maven的其他项目也生效的话。需要修改全局的settings.xml文件。 修改settings.xml为 12345678910111213141516171819202122232425262728293031&lt;profiles&gt;……………&lt;profile&gt; &lt;id&gt;myprofile&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://10.110.13.14:8081/nexus/content/groups/inspur-jszx/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://10.110.13.14:8081/nexus/content/groups/inspur-jszx/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt;……………&lt;profiles&gt; 追加激活profile 123&lt;activeProfiles&gt; &lt;activeProfile&gt;central&lt;/activeProfile&gt; &lt;/activeProfiles&gt; 之后所有本机的Maven项目就在私服下载组件。 项目的发布: 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;user-release&lt;/id&gt; &lt;name&gt;UserProject Release&lt;/name&gt; &lt;url&gt;http://192.168.1.103:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;user-snapshots&lt;/id&gt; &lt;name&gt;UserProject SNAPSHOTS&lt;/name&gt; &lt;url&gt;http://192.168.1.103:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 注意配置了还是发布项目到私服失败，原因为没有权限，会出现401错误码，原因就是权限不够。 配置权限在settings.xml 注意Respository中的id一定要和server下的id一致，切记！！否则出现权限问题。 然后运行发布 1mvn clean deploy 在控制台发布成功 然后进入到私服上的仓库中，看一下确实存在刚刚发布的项目 手动上传用admin管理员权限用户登录，找到相应的上传配置，分别选中填写信息就最后Upload构件就可以了]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>介绍</tag>
        <tag>nexus</tag>
        <tag>私服</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven项目命名规范]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2FMaven%E9%A1%B9%E7%9B%AE%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/03/maven-named-project/ 官方文档介绍Guide to naming conventions on groupId, artifactId and versiongroupId will identify your project uniquely across all projects, so we need to enforce a naming schema. It has to follow the package name rules, what means that has to be at least as a domain name you control, and you can create as many subgroups as you want. Look at More information about package names.eg. org.apache.maven, org.apache.commons A good way to determine the granularity of the groupId is to use the project structure. That is, if the current project is a multiple module project, it should append a new identifier to the parent’s groupId. eg. org.apache.maven, org.apache.maven.plugins, org.apache.maven.reporting artifactId is the name of the jar without version. If you created it then you can choose whatever name you want with lowercase letters and no strange symbols. If it’s a third party jar you have to take the name of the jar as it’s distributed.eg. maven, commons-math version if you distribute it then you can choose any typical version with numbers and dots (1.0, 1.1, 1.0.1, …). Don’t use dates as they are usually associated with SNAPSHOT (nightly) builds. If it’s a third party artifact, you have to use their version number whatever it is, and as strange as it can look.eg. 2.0, 2.0.1, 1.3.1 以上内容是maven官网文档命名约定指南 总结groupId:定义当前Maven项目隶属的实际项目，例如org.sonatype.nexus，此id前半部分org.sonatype代表此项目隶属的组织或公司，后部分代表项目的名称，如果此项目多模块话开发的话就子模块可以分为org.sonatype.nexus.plugins和org.sonatype.nexus.utils等。特别注意的是groupId不应该对应项目隶属的组织或公司，也就是说groupId不能只有org.sonatype而没有nexus。 例如：我建立一个项目，此项目是此后所有项目的一个总的平台，那么groupId应该是org.limingming.projectName,projectName是平台的名称，org.limingming是代表我个人的组织，如果以我所在的浪潮集团来说的话就应该是com.inspur.loushang。 artifactId是构件ID，该元素定义实际项目中的一个Maven项目或者是子模块，如上面官方约定中所说，构建名称必须小写字母，没有其他的特殊字符，推荐使用“实际项目名称－模块名称”的方式定义，例如：spirng-mvn、spring-core等。 推荐格式：使用实际项目名称作为artifactId的前缀，紧接着为模块名称举例：nexus-indexer、spring-mvc、hibernate-c3po……这些id都是以实际项目名称作为前缀，然后接着一个中划线，再紧跟项目的模块名称，默认情况下maven会在artifactId添加version作为最后生成的名称。例如：spirng-mvn-2.0.0.jar]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>命名</tag>
        <tag>规范</tag>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven清除LastUpdated文件]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2FMaven%E6%B8%85%E9%99%A4LastUpdated%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/03/maven-delete-lastupdated-file/ 介绍maven仓库中的某个构件如果因为网络或者其他的原因，没有下载成功或者下载被中断，将会出现一个LastUpdated的文件，这个时候，就算网络好了，也不能正常使用这个构件。 在linux系统上可以切换到仓库的目录下执行： 1find ./ -name "*.lastUpdated" -exec grep -q "Could not transfer" &#123;&#125; \; -print -exec rm &#123;&#125; \; 在windows系统下可以保存到后缀为bat的文件中修改仓库的目录执行：12345678rem 这里写你的仓库路径set REPOSITORY_PATH=E:\storage\maven\repositoryrem 正在搜索...for /f "delims=" %%i in ('dir /b /s "%REPOSITORY_PATH%\*lastUpdated*"') do ( del /s /q %%i)rem 搜索完毕pause 执行上面的命令后删掉本地仓库的.lastupdate文件，重新构建，必要的情况可以开vpn下载。某些一直报错的jar包，校验MD5，不对的请删掉重新构建 错误总结Maven项目导入eclipse中很多时候都出现报错的情况，出错的原因大致可以分为下列几种： JDK版本不一致 网络问题无法下载，可以尝试开vpn下载 私有jar包]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>清除</tag>
        <tag>lastUpdated</tag>
        <tag>脚本</tag>
        <tag>无法构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven安装jar包到仓库]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2FMaven%E5%AE%89%E8%A3%85jar%E5%8C%85%E5%88%B0%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/03/maven-install-jar-to-repository/ 介绍废话就不说了： 1mvn install:install-file –Dfile=loushang-home-6.0.RELEASE.jar –DgroupId=org.loushang.framework –DartifactId=loushang-home –Dversion=6.0.RELEASE –Dpackaging=jar python脚本批量上传Jar包到私服123456789101112131415161718192021222324252627from xml.etree.ElementTree import Element, SubElement, tostring,ElementTreeimport globimport osdef mvn_script(filename): return "mvn deploy:deploy-file -DrepositoryId=open2-baidu -Durl=http://10.100.10.131:8119/nexus-2.3.0-04/content/repositories/open2-baidu -DgroupId=com.pzoom -DartifactId="+filename[0:len(filename)-4]+" -Dversion=1.0 -Dpackaging=jar -Dfile="+filenamedef writeDependency(filename): dependencies = Element("dependencies") dependency = SubElement(dependencies,"dependency") groupId = SubElement(dependency, "groupId") groupId.text = "com.pzoom" artifactId = SubElement(dependency, "artifactId") artifactId.text = filename[0:len(filename)-4] version = SubElement(dependency, "version") version.text="1.0" ElementTree(dependencies).write("out.xml")files = glob.glob('*.jar')for file in files: writeDependency(file) print(file) os.system(mvn_script(file)) print('upload success') print('delete the file : '+file) os.remove(file) 中间的参数部分可以自行更改。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>仓库</tag>
        <tag>安装</tag>
        <tag>Maven</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven多web模块打包问题]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2Fmaven%E5%A4%9Aweb%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/03/maven-webs-moudle/ 介绍在项目开发中可能会遇到这种那种的maven问题，尤其是在企业原有的开发模式转换到mavne方式进行开发的时候，以下就列出在企业项目拆分的过程中总结的maven多个子web模块的整合遇到的问题。 在各个子模块中可以添加，注意relativePath，在子模块中设置，可以在项目构建时先在本地项目中查找，使用../.. ，然后在去仓库和私服查找父pom: 123456&lt;parent&gt; &lt;groupId&gt;com.founder.fix.fixflow&lt;/groupId&gt; &lt;artifactId&gt;fixflow-root&lt;/artifactId&gt; &lt;version&gt;5.0&lt;/version&gt; &lt;relativePath&gt;../..&lt;/relativePath&gt; &lt;/parent&gt; 在依赖中添加对另一个web模块打成jar包的依赖，使用war，如下： 123456&lt;dependency&gt; &lt;groupId&gt;org.loushang.framework&lt;/groupId&gt; &lt;artifactId&gt;loushang-framework&lt;/artifactId&gt; &lt;version&gt;$&#123;loushang-framework.version&#125;&lt;/version&gt; &lt;type&gt;war&lt;/type&gt;&lt;/dependency&gt; 可以声明多个依赖； build中添加相关设置，如果不添加的话可以设置是否：123456789101112131415161718192021222324&lt;build&gt; &lt;finalName&gt;lousing&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 合并多个war --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;packagingExcludes&gt;WEB-INF/web.xml&lt;/packagingExcludes&gt; &lt; overlays&gt; &lt;!-- 声明合并war --&gt; &lt;overlay&gt; &lt;groupId&gt;com.founder.fix.fixflow&lt;/groupId&gt; &lt;artifactId&gt;fixflow-webapp-taskcenter&lt;/artifactId&gt; &lt;excludes&gt; &lt;!-- 声明排除war包中的部分 --&gt; &lt;exclude&gt;*/web.xml,WEB-INF/lib/*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/overlay&gt; &lt;/overlays&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 注意在被合并的子模块没有web.xml部分，要声明： 1234567891011121314151617181920212223&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;&lt;version&gt;2.6&lt;/version&gt;&lt;configuration&gt; &lt;!—－ 设置将其他文件打包到war包 --&gt;&lt;webResources&gt;&lt;resource&gt;&lt;directory&gt;$&#123;basedir&#125;/../commonFiles/jsp&lt;/directory&gt;&lt;!-- &lt;directory&gt;src/main/resources&lt;/directory&gt; --&gt;&lt;filtering&gt;true&lt;/filtering&gt; &lt;targetPath&gt;/&lt;/targetPath&gt;&lt;/resource&gt;&lt;/webResources&gt;&lt;!-- 解决web模块中没有web.xml报错的问题 --&gt;&lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;!-- 解决打包时候排除空文件不打包 --&gt;&lt;includeEmptyDirectories&gt;true&lt;/includeEmptyDirectories&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;/plugins&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>web</tag>
        <tag>模块</tag>
        <tag>打包</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven的Scope类型及引用本地jar包方式]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2FMaven%E7%9A%84Scope%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0jar%E5%8C%85%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/03/maven-scope-types/ 介绍Maven配置中我们经常会配置使用Scope，scope的默认值是compile，在开发过程中很多时候会用到引用本地jar包的方式，通过scope的一个配置也能实现引用本地jar包，通过英文翻译我们也能知道，这个配置声明的是当前“构件”能作用的范围是在哪儿，scope共有5个值，下面我们分别看一下。 scope的value compile这是默认范围，如果未指定则使用。编译依赖项在项目的所有类路径中都可用。此外，这些依赖项能被传递到依赖的项目，也就是说能作用在classpath范围内，声明为compile的构件也会被打包到应用中。 test此范围表示正常使用应用程序不需要依赖关系，并且仅适用于测试编译和执行阶段。此范围不具有传递性。scope为test表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的就是junit。 runntimerunntime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比跳过了编译而已，oracle jdbc驱动包就是一个很好的例子，一般scope为runntime。另外runntime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。 provided这个和编译很相似，provided意味着打包的时候可以不用打包进去，jdk或者容器(Web Container)会这个提供这个构件的依赖，意味着容器内会包含这个构件，例如servlet.jar在tomcat中。事实上该依赖，理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包的时候被排除掉了。此范围仅在编译和测试类路径中可用，并且不可传递。 system此范围与提供的类似，从参与度来说，和provided相同，被依赖项不会从maven仓库找，而是在本地文件系统找，一定需要配合systemPath属性使用。 scope的依赖传递A–&gt;B–&gt;C。当前项目为A，A依赖于B，B依赖于C。知道B在A项目中的scope，那么怎么知道C在A中的scope呢？答案是：当C是test或者provided时，C直接被丢弃，A不依赖C；否则A依赖C，C的scope继承于B的scope。 PS：还有一个补充项import此范围仅在部分中的pom类型的依赖项上受支持。它指示要使用指定POM的部分中的有效依赖项列表替换的依赖项。由于它们被替换，具有导入范围的依赖性实际上不参与限制依赖性的传递性。 参考地址参考地址中内容如下： 123456789101112131415There are 6 scopes available:compileThis is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated to dependent projects.providedThis is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope provided because the web container provides those classes. This scope is only available on the compilation and test classpath, and is not transitive.runtimeThis scope indicates that the dependency is not required for compilation, but is for execution. It is in the runtime and test classpaths, but not the compile classpath.testThis scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases. This scope is not transitive.systemThis scope is similar to provided except that you have to provide the JAR which contains it explicitly. The artifact is always available and is not looked up in a repository.importThis scope is only supported on a dependency of type pom in the &lt;dependencyManagement&gt; section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM&apos;s &lt;dependencyManagement&gt; section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency.Each of the scopes (except for import) affects transitive dependencies in different ways, as is demonstrated in the table below. If a dependency is set to the scope in the left column, transitive dependencies of that dependency with the scope across the top row will result in a dependency in the main project with the scope listed at the intersection. If no scope is listed, it means the dependency will be omitted. 配置应用本地jar包有一次由于私服出了问题，我又不想将jar包安装到本地仓库，所以想直接引用本地的jar包，所以就使用了接下来的设置。这样有个问题是我们可以声明用到此jar包进行编译构建，但是最终的结果中不会将此jar包打包到项目中，也不会将此jar包安装到仓库里，我觉得如果非要采用这种方式进行引用构建的话，将jar包放到webapp下WEBINF下的lib文件夹中引用，通过${project.basedir}这个配置获取项目的路径，这样就会将jar包构建到结果项目中。 12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.ibm&lt;/groupId&gt; &lt;artifactId&gt;jms&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/lib/jms.jar&lt;/systemPath&gt; &lt;/dependency&gt; 我们声明了scope为system， 它使用起来和provided差不多，即此依赖由系统提供，但是与provided有点不同的是，它需要显式的使用systemPath指定lib所在的路径，如上systemPath。 其他当然我们也可以通过配置插件打包其他目录文件到war包的方式发布构件，配置如下，看是否可以借鉴一下： 12345678910111213141516&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;&lt;configuration&gt;&lt;webResources&gt;&lt;resource&gt;&lt;directory&gt;$&#123;project.basedir&#125;/lib&lt;/directory&gt;&lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt;&lt;filtering&gt;true&lt;/filtering&gt;&lt;includes&gt;&lt;include&gt;**/*.jar&lt;/include&gt;&lt;/includes&gt;&lt;/resource&gt;&lt;/webResources&gt;&lt;/configuration&gt;&lt;/plugin&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>scope</tag>
        <tag>类型</tag>
        <tag>system</tag>
        <tag>本地</tag>
        <tag>jar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven多WEB模块打包排除jar包冲突的配置建议]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2FMaven%E5%A4%9AWEB%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%8E%92%E9%99%A4jar%E5%8C%85%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[原文：http://limingming.org/index.php/2018/12/03/web-module-pack-…-of-jar-confilct/ 前提在原有的web项目基础上拆分出了多个web项目，后台代码还是在各个web模块中，现在的需求是要合并多个web模块整合到一个war中部署。 配置建议新建打包的web模块用以合并多个web模块项目，在pom中声明合并打包的各个模块，例如要合并A模块和B模块，如下： 123456789101112131415161718192021222324252627&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;A&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;type&gt;war&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;A&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;B&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;type&gt;war&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;B&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 我们需要在合并打包的项目中依赖要合并的各个war包和各个模块的pom。 排除各个模块的lib： 排除各个模块的lib 123456789101112131415161718192021222324252627282930&lt;build&gt;&lt;finalName&gt;B&lt;/finalName&gt;&lt;plugins&gt; &lt;!-- 合并多个war --&gt;&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;&lt;version&gt;2.6&lt;/version&gt;&lt;configuration&gt;&lt;overlays&gt; &lt;!-- 声明合并war --&gt;&lt;overlay&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;A&lt;/artifactId&gt;&lt;excludes&gt;&lt;!-- 声明排除war包中的部分 --&gt;&lt;exclude&gt;WEB-INF/lib/*&lt;/exclude&gt;&lt;/excludes&gt;&lt;/overlay&gt;&lt;/overlays&gt;&lt;overlays&gt; &lt;!-- 声明合并war --&gt;&lt;overlay&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;B&lt;/artifactId&gt;&lt;excludes&gt;&lt;!-- 声明排除war包中的部分 --&gt;&lt;exclude&gt;WEB-INF/lib/*&lt;/exclude&gt;&lt;/excludes&gt;&lt;/overlay&gt;&lt;/overlays&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 大家有哪些多模块开发构建的规范，很希望能给出你的建议到原文评论，谢谢。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>排除</tag>
        <tag>多模块</tag>
        <tag>web</tag>
        <tag>合并</tag>
        <tag>冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在maven的web项目中内嵌tomcat插件执行war包]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2F%E5%9C%A8maven%E7%9A%84web%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%86%85%E5%B5%8Ctomcat%E6%8F%92%E4%BB%B6%E6%89%A7%E8%A1%8Cwar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[原文地址：http://limingming.org/index.php/2018/12/03/maven-tomcat-plugin/ 环境要求Unix System\windwos\macOSJDK 1.7+Maven 3.0 or later 我测试的编译环境是：macOS10.11.6和windows10jdk1.8/jdk1.7Maven 3.3.9 我的本机开发环境：MacOS 10.11.6eclipse Mars.2 在pom中配置tomcat-maven-plugin123456789101112131415161718192021222324&lt;project&gt; ... &lt;packaging&gt;war&lt;/packaging&gt; ... &lt;build&gt; ... &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat6-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; ... &lt;/plugins&gt; ... &lt;/build&gt; ...&lt;/project&gt; 运行war包执行 tomcat7:run-war或者tomca6:run-war 如果想要修改其他配置可以在标签下添加如下等配置 1234567&lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/demo&lt;/path&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;finalName&gt;demo&lt;/finalName&gt; &lt;server&gt;tomcat7&lt;/server&gt; &lt;/configuration&gt; 参考：http://tomcat.apache.org/maven-plugin-2.2/]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>插件</tag>
        <tag>内嵌</tag>
        <tag>可执行</tag>
        <tag>war</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven项目中WEB模块中后台代码打成jar包]]></title>
    <url>%2F2018%2F12%2F03%2FMaven%2FMaven%E9%A1%B9%E7%9B%AE%E4%B8%ADWEB%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%90%8E%E5%8F%B0%E4%BB%A3%E7%A0%81%E6%89%93%E6%88%90jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[原文地址：http://limingming.org/index.php/2018/12/02/maven-class-to-jar/ 描述 将web模块的后台代码打成jar 包发布到target目录下（war包中正常编译的class依然存在） 123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-a-jar&lt;/id&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 将web模块的后台代码打成jar包发布到WEB_INF/lib下 123456789101112131415161718192021222324&lt;build&gt; &lt;finalName&gt;manage-elasticsearch-authorization&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;!-- 释放将项目的类文件打成jar放到lib目录中。 打成jar的好处是：只修改class时，可以只更新jar。 --&gt; &lt;archiveClasses&gt;true&lt;/archiveClasses&gt; &lt;webResources&gt; &lt;!-- src/main/resources是默认的资源目录。 当archiveClasses=true时，resources中的文件资源会被打到jar中； 当archiveClasses=false时，resources中的文件资源在war的根目录。 --&gt; &lt;resource&gt; &lt;!-- resources作为source folder，不会被打到jar中。 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;targetPath&gt;WEB-INF/classes&lt;/targetPath&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 以上内容仅为配置后台代码生成到jar包中，一般用于发布应用。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>jar</tag>
        <tag>后台</tag>
        <tag>程序</tag>
        <tag>代码</tag>
        <tag>lib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建WEB可执行的jar包]]></title>
    <url>%2F2018%2F12%2F02%2FMaven%2F%E6%9E%84%E5%BB%BAWEB%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[原文地址：http://limingming.org/index.php/2018/12/02/build-an-executable-war-tomcat/ 这个博客来自于很久在CSDN上写的，可能现在可能已经发生些变化，但是并不影响拿来参考借鉴它的使配置的方式和思想。 构建可执行jar包文档（tomcat7-maven-plugin）：JDK 1.7+Maven 3.0 or later tomcat7-maven-plugin version 2.1/2.0/2.0-beta-1 环境要求Unix System\windwos\macOSJDK 1.7+Maven 3.0 or later 我测试的编译环境是：macOS10.11.6和windows10jdk1.8/jdk1.7Maven 3.3.9我的本机开发环境：MacOS 10.11.6eclipse Mars.2 在pom中配置tomcat7-maven-plugin1234567891011121314151617181920212223242526272829&lt;project&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;tomcat-run&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;exec-war-only&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;configuration&gt; &lt;path&gt;demo&lt;/path&gt; &lt;!-- optional, needed only if you want to use a preconfigured server.xml file --&gt; &lt;serverXml&gt;src/main/tomcatconf/server.xml&lt;/serverXml&gt; &lt;!-- optional values which can be configurable --&gt; &lt;attachArtifactClassifier&gt;default value is exec-war but you can customize&lt;/attachArtifactClassifier&gt; &lt;attachArtifactClassifierType&gt;default value is jar&lt;/attachArtifactClassifierType&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 执行构建生成jar包执行 1mvn clean install 会在target下生成相应的jar包 如果想要修改jar包名称，可以在标签中定义标签修改生成的jar包名称 执行构建出来的jar包部署应用执行构建出来的jar包： 1java -jar yourjar 其他参数： 1234567891011121314151617181920usage: java -jar [path to your exec war jar] -ajpPort &lt;ajpPort&gt; ajp port to use -clientAuth enable client authentication for https -D &lt;arg&gt; key=value -extractDirectory &lt;extractDirectory&gt; path to extract war content, default value: .extract -h,--help help -httpPort &lt;httpPort&gt; http port to use -httpProtocol &lt;httpProtocol&gt; http protocol to use: HTTP/1.1 or org.apache.coyote.http11.Http11Nio Protocol -httpsPort &lt;httpsPort&gt; https port to use -keyAlias &lt;keyAlias&gt; alias from keystore for ssl -loggerName &lt;loggerName&gt; logger to use: slf4j to use slf4j bridge on top of jul -obfuscate &lt;password&gt; obfuscate the password and exit -resetExtract clean previous extract directory -serverXmlPath &lt;serverXmlPath&gt; server.xml to use, optional -X,--debug debug 例如：如果需要改变启动容器的端口号(默认为8080） 1java -jar yourjar -httpPort 8081 PS： 在测试过程中使用到的插件版本如下： 2.0、2.0-beta-1、2.1、2.2 都可以正常构建生成jar包，但是在执行启动jar包的过程中，在jdk1.8的环境下： 2.1的版本正常，可以正常执行部署，启动运行2.0和2.0-beta-1版本可以正常部署，但是启动tomcat访问中报java.io异常，和jdk执行版本有关，经过多次测试，更换为jdk1.7执行没有可以正常使用。在jdk1.8环境和jdk1.7环境下2.2版本都存在不可以正常创建webapp文件夹，也不可以将应用部署到webapp中，如果手动将jar包的相关内容部署进.extract/再次执行启动命令可以正常使用综上：可以使用2.1版本的插件。 在maven的web项目中内嵌tomcat插件执行war包环境要求Unix System\windwos\macOSJDK 1.7+Maven 3.0 or later 我测试的编译环境是：macOS10.11.6和windows10jdk1.8/jdk1.7Maven 3.3.9我的本机开发环境：MacOS 10.11.6eclipse Mars.2 在pom中配置tomcat-maven-plugin123456789101112131415161718192021222324&lt;project&gt; ... &lt;packaging&gt;war&lt;/packaging&gt; ... &lt;build&gt; ... &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat6-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; ... &lt;/plugins&gt; ... &lt;/build&gt; ...&lt;/project&gt; 运行war包执行 tomcat7:run-war或者tomca6:run-war 如果想要修改其他配置可以在 标签下添加如下等配置 1234567&lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/demo&lt;/path&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;finalName&gt;demo&lt;/finalName&gt; &lt;server&gt;tomcat7&lt;/server&gt; &lt;/configuration&gt; 参考文档]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>插件</tag>
        <tag>构建</tag>
        <tag>执行</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven依赖管理]]></title>
    <url>%2F2018%2F12%2F01%2FMaven%2FMaven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[作者：李明明原文地址：http://limingming.org/index.php/2018/11/30/maven-manage-dependency/ 直接依赖和间接依赖mane最大的好处就是能够方便的声明第三方的jar包，只需要在pom中进行简单的声明就可以将此jar包依赖到项目中，那什么是直接依赖呢？就是在项目中直接声明的这些依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 排除依赖间接依赖是由直接依赖间接依赖到项目的那些jar包，当项目依赖于某一第三方Jar包，而这一第三方Jar包又给我们间接性的带来了大量的依赖,这种间接性的依赖，不仅浪费了磁盘空间，而且也可能带来潜在的冲突,因此我们需要将这些不需要的依赖从项目中排除，对项目进行一个瘦身，这时我们需要对Pom进行优化,再或者，通过间接性依赖获得的Jar包版本过低，而这些低版本的Jar包无法满足我们项目的需求，这时我们也需要将这些低版本的Jar包排除掉，也就是下面的exclusion标签 1234567891011121314151617181920212223242526&lt;dependency&gt; &lt;groupId&gt;net.sf.spring-json&lt;/groupId&gt; &lt;artifactId&gt;spring-json&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib-full&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 工具筛选Maven没有任何声明排除jar包的情况下，默认是将全部jar包引入进来，有时候当前项目使用的jar包与依赖的第三方的jar包不同，会出现同个项目构建后出现一个jar包几个不同版本同时存在的问题，有时会引发jar包冲突可以通过命令或者是在IDE中查看依赖树，排查依赖关系： 1mvn dependency : list 经过Maven解析之后，就会构成一个依赖树也可以使用命令查看当前项目的依赖树： 1mvn dependency : tree 使用命令分析当前当前项目的依赖： 1mvn dependency : analyze 该命令执行结果的两个重要部分：Used undeclared dependencies: 表示项目中使用到的，但是没有显示声明的依赖Unused declared dependencies: 表示项目中未使用的，但显示声明的依赖该命令只会分析编译主代码和测试代码需要用到的依赖，一些执行测试和运行时需要的依赖它无法发现。 ps:exclusions是在某个具体依赖里面配置的，也就是说要找到需排除的jar包的依赖坐标 以下是eclipse中的通过配置工具查看依赖、删除依赖的位置： 大开pom.xml,选中下发Dependency Hierarchy，选中右侧jar包，右键排除依赖就可以了。 配置可选maven还有个可选依赖的设置，在当前项目A设置对某个依赖是可选的: 12345678&lt;optional&gt;true&lt;/optional&gt;&lt;dependency&gt; &lt;groupId&gt;sample.ProjectB&lt;/groupId&gt; &lt;artifactId&gt;Project-B&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 这样设置后，再有个项目X依赖A时，如果X中没有B中的类路径，则不会把B依赖加进来。 依赖规则大家看到直接依赖和间接依赖之后可能会有疑问，由不同的直接依赖产生的同一jar包不同版本的jar包之间的间接依赖怎么进行排除？这就要讲到maven的规则： 第一声明者优先（对于简介依赖） 例如：A项目依赖B、C两个项目，B和C又同时依赖D项目（依赖的D项目版本可能还是不同的），那就按照第一声明者优先的规则，谁先声明就用谁的，也就是对于间接依赖，路径相同的情况下，第一声明优先。 最后声明者优先（对于同一pom中直接依赖的同一jar包的不同版本间） 在pom中声明了同一jar包的不同版本，谁声明在后面就采用谁。 最短路径优先（对于间接依赖） 从名称就可以看出对于间接依赖的jar包，谁的间接依赖的路径短就采用谁的，例如A依赖B，B依赖D，而A依赖C，C依赖E，E依赖F，F依赖D，采用最短的依赖A-&gt;B-&gt;D的依赖版本。 dependencyManagement与dependenciesMaven已经具备了面向对象的思想，面向对象的三要素就是多态、继承、封装，dependencies与dependencyManagement就涉及到的是继承的思想。 多模块项目中，各个模块一般均需要Junit测试Jar包，因此在父Pom配置文件中，我们可以将这个依赖写入： 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 此模块的各个子模块就可以直接继承此jar包了。 再想想，有一些依赖，是各个子模块所特有的，如果放在父模块的POM中进行定义,那么所有继承了该父模块的子模块均会存在该依赖，这样的结果是啥，项目中存在大量冗余Jar包，不但浪费了磁盘，而且也不利于管理，所以： 12345678910111213141516171819dependencyManagement&gt; &lt;!-- 配置项目依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;zookeeper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.opensymphony.quartz&lt;/groupId&gt; &lt;artifactId&gt;quartz-all&lt;/artifactId&gt; &lt;version&gt;$&#123;quartz.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;oro&lt;/groupId&gt; &lt;artifactId&gt;oro&lt;/artifactId&gt; &lt;version&gt;$&#123;oro.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencyManagement&gt; 我们可以这样定义jar包在父模块，这样子模块就不会继承了，如果子模块需要用到jar包就需要重新声明： 1234567&lt;!-- 配置项目依赖 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 可以省略版本，这样有利于控制版本，当然也可以自己定义在子模块中版本，这样将采用子模块中的版本。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>依赖管理</tag>
        <tag>排除</tag>
        <tag>依赖</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK及openJDK版本更迭]]></title>
    <url>%2F2018%2F12%2F01%2FJava%2FJDK%E5%8F%8AopenJDK%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD%2F</url>
    <content type="text"><![CDATA[作者: 李明明http://limingming.org/index.php/2018/11/30/jdk-and-openjdk-version/ 道听途说最近浪潮公司内部除了持之以恒的宣扬“奋进者精神”之外，可能最大的一件事情就是JDK要收费了，观望着是不是要更换为openJDK，9月20多号Oracle发布了java 11，同时也发布后续更新策略，那是怎么收费的呢？ 追根溯源oracle jdk 和open jdk有什么区别？ Java 11授权使用BCL协议，没有个人、商业版了，也就是说，如果要使用的必须要付出代价，代价就是Money，不禁想说一句：万恶的资本主义。 Open jdk使用GPL协议 两种协议有什么区别呢？首先BCL不是开源协议，简要来介绍BCL协议的话，就是你一点也不能更改我的jdk，也不能基于我开发周边类库发布，如果基于我这个BCL开发，需要判断你是个人版还是商业版，再收钱！GPL是开源协议，JDK是可以更改的，基于这个GPL开发的东西也是属于GPL协议的，也要开源出来。 补充：由于历史原因，OpenJDK是JDK的开放源码版本，也就是上面我们说的GPL协议的，但是到了JDK7的时候OpenJDK已经为jdk的主干开发，oracle jdk是在openjdk基础上进行封板发布的，所以大部分的源代码是相同的，只不过其中有部分少量的源代码被替换掉，使用JRL发布，以上jdk7的过程中就产生了微妙的变化，openjdk 是GPL协议的，完全可以商用，但是JRL只允许个人使用不允许商用。 版本更迭大体梳理一下JDK版本更迭过程中产生了那些新特性，也借此机会梳理一下自己JAVA的知识脉络。 JDK5 泛型“ 123ArrayList list=new ArrayList()------&gt;ArrayList&lt;Integer&gt;list=new ArrayList&lt;Integer&gt;(); 枚举 静态导入 123456789101112import static java.lang.System.out``` 3. 可变参数（Varargs）4. 内省（Introspector），主要用于操作JavaBean中的属性，通过getXxx/setXxx。一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。泛型(Generic)（包括通配类型/边界类型等）5. For-Each循环 ```javai=0;i&lt;a.length;i++------------&gt;for(int i:a)&#123;......&#125; 注解 协变返回类型：实际返回类型可以是要求的返回类型的一个子类型 自动装箱拆箱： 123int i=list.get(0).parseInt();--------&gt;int i=list.get(0); 我们经常阅读的编程思想也是在jdk5的版本上进行编写的，可惜作者忙别的事情去了，没有更新了，可能觉得java更新至此也应该很全面了吧。 JDK6 AWT新增加了两个类:Desktop和SystemTray，其中前者用来通过系统默认程序来执行一个操作，如使用默认浏览器浏览指定的URL,用默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件),用系统默认的打印机打印文档等。后者可以用来在系统托盘区创建一个托盘程序。 使用JAXB2来实现对象与XML之间的映射，可以将一个Java对象转变成为XML格式，反之亦然 StAX，一种利用拉模式解析(pull-parsing)XML文档的API。类似于SAX，也基于事件驱动模型。之所以将StAX加入到JAXP家族，是因为JDK6中的JAXB2和JAX-WS 2.0中都会用StAX。 使用Compiler API，动态编译Java源文件，如JSP编译引擎就是动态的，所以修改后无需重启服务器。（刚知道是从这里开始可以动态编译的） 轻量级Http Server API，据此可以构建自己的嵌入式HttpServer,它支持Http和Https协议。 插入式注解处理API(PluggableAnnotation Processing API) 提供了Console类用以开发控制台程序，位于java.io包中。据此可方便与Windows下的cmd或Linux下的Terminal等交互。 对脚本语言的支持如: ruby,groovy, javascript Common Annotations，原是J2EE 5.0规范的一部分，现在把它的一部分放到了J2SE 6.0中 嵌入式数据库 Derby 增强的for循环语句 1234567Integer[] numbers = computeNumbers();for (int i=0; i &lt; numbers.length ; i++)sum += numbers[i];||int sum = 0;for ( int number: computeNumbers() )sum += number; 监视和管理Java SE 6中对内存泄漏增强了分析以及诊断能力。当遇到java.lang.OutOfMemory异常的时候，可以得到一个完整的堆栈信息，并且当堆已经满了的时候，会产生一个Log文件来记录这个致命错误。另外，JVM还添加了一个选项，允许你在堆满的时候运行脚本。 插入式注解处理插入式注解处理API(JSR 269)提供一套标准API来处理Annotations 安全性 如果你细细想来jdk6用到的新特性的确很少 JDK7 对Java集合（Collections）的增强支持，可直接采用[]、{}的形式存入对象，采用[]的形式按照索引、键值来获取集合中的对象。如： 12345List&lt;String&gt;list=[“item1”,”item2”];//存Stringitem=list[0];//直接取Set&lt;String&gt;set=&#123;“item1”,”item2”,”item3”&#125;;//存Map&lt;String,Integer&gt; map=&#123;“key1”:1,”key2”:2&#125;;//存Intvalue=map[“key1”]; 在Switch中可用String 数值可加下划线用作分隔符（编译时自动被忽略） 支持二进制数字，如： 12345678910int binary= 0b1001_1001; ``` 5. 简化了可变参数方法的调用 6. 调用泛型类的构造方法时，可以省去泛型参数，编译器会自动判断。 7. Boolean类型反转，空指针安全,参与位运算 8. char类型的equals方法: ```javabooleanCharacter.equalsIgnoreCase(char ch1, char ch2) 安全的加减乘除: 1Math.safeToInt(longv); Math.safeNegate(int v); Math.safeSubtract(long v1, int v2);Math.safeMultiply(int v1, int v2); Map集合支持并发请求，注HashTable是线程安全的，Map是非线程安全的。但此处更新使得其也支持并发。另外，Map对象可这样定义： 1Map map = &#123;name:”xxx”,age:18&#125;; JDK8 接口的默认方法：即接口中可以声明一个非抽象的方法做为默认的实现，但只能声明一个，且在方法的返回类型前要加上“default”关键字。2.Lambda 表达式：是对匿名比较器的简化，如： 1Collections.sort(names,(String a, String b) -&gt; &#123; returnb.compareTo(a);&#125;); 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字。如： 123456Collections.sort(names,(String a, String b) -&gt; b.compareTo(a));``` 或：```javaCollections.sort(names, (a, b) -&gt; b.compareTo(a)); 函数式接口：是指仅仅只包含一个抽象方法的接口，要加@FunctionalInterface注解 使用 :: 关键字来传递方法或者构造函数引用 多重注解 还增加了很多与函数式接口类似的接口以及与Map相关的API等 其实以上的只不过是对于各个版本功能的简要摘录，如果想要详细了解的话可以看官方文档，平时用到的就是到jdk8，从jdk5到现在用jdk8，jdk9、和10还从来没有接触过。 最后附上相关项目的地址： OpenJDK官网:http://openjdk.java.net/ OpenJDK源码库：http://hg.openjdk.java.net/ OpenJDK源码库：http://hg.openjdk.java.net/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>open jdk</tag>
        <tag>版本</tag>
        <tag>功能</tag>
        <tag>区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下npm安装命令不生效]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C%2Fmac%E4%B8%8Bnpm%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E4%B8%8D%E7%94%9F%E6%95%88%2F</url>
    <content type="text"><![CDATA[介绍如果我们平时使用node进行开发的话，经常会使用node安装一些其他的命令，比如安装淘宝的cnpm（npm install -g cnpm –registry=https://registry.npm.taobao.org），安装vue（npm install vue）命令等等，按道理应该是命令可以直接使用的。 我们在mac上安装完成nodejs，node的命令是在/usr/local/bin下面，可以直接使用，但是我们通过node命令安装的其他工具是在/usr/local/Cellar/node/10.8.0/lib/node_modules/vue-cli/bin/vue,我使用的10.8.0的版本，如果使用其他版本会在其他版本号路径下面，这个安装的路径一般都会统一创建链接到/usr/local/Cellar/node/10.8.0/bin下，所以我们把这个路径添加到我们的环境变量里面就可以了。 解决办法添加到环境变量的一个方式，比如修改~/.bash_profile文件，添加： 12#node安装包下的相关命令cnpm、node等命令export PATH="$PATH:/usr/local/Cellar/node/10.8.0/bin" 执行: 1source ~/.bash_profile 就可以使用cnpm等命令了。]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>命令</tag>
        <tag>Mac</tag>
        <tag>npm</tag>
        <tag>不生效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[作者 李明明转载请注明出处： http://limingming.org/index.php/2018/11/28/markdown-grammar/ 介绍 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科;Markdown 是一种轻量级标记语言，让写作者专注于写作而不用关注样式。很多有编程基础的程序员比较喜欢使用Markdown进行编写，github项目中README.md都是markdown编写的；以下我讲述通用的语法，保留各个编辑器通用的，还有很多markdown语法是各个编辑器独有的，大家使用过程中可以注意一下，平时使用mac上的编辑器,也为大家分享一下。 语法介绍标题123# 一级标题## 二级标题### 三级标题 演示图效果： 强调 在Markdown中，可以使用 * 或 _ 来表示斜体和加粗。 使用一个*或者_来表示斜体，两个来表示加粗。1234A： *我是斜体*B: _我也是斜体_C：**我是粗体**D: __我也是粗体__ 演示图效果： 例子（摘抄于马克飞象“案例，马克飞象是一个很不错的markdown编辑器，为markdown各种类型的语法提供了一个良好的支持）12345**马克飞象**是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： - **功能丰富** ：支持高亮代码块、*LaTeX* 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；- **得心应手** ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web；- **深度整合** ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 锚点markdown会针对每个标题，在解析时都会添加锚点 id，例如： 123# 介绍# 介绍1那我们就可以使用“[访问介绍标题的锚点](#介绍)”,来定义锚点 测试： 访问介绍标题的锚点; 引用Markdown 标记区块引用和 email 中用 &gt; 的引用方式类似，只需要在整个段落的第一行最前面加上 &gt; ： 演示： 列表标记通常放在句子最左边，项目标记后面要接一个字符的空格。 无序列表：使用星号、加号或是减号作为列表标记123* 我是无序列表A + 我是无序列表B - 我是无序列表C 有序列表：使用数字接着一个英文句点1231. 我是无序列表12. 我是无序列表2 3. 我是无序列表3 3.代办列表(简书暂不支持此方式）12- [ ] 不勾选- [x] 勾选 补充如果在列表中使用引用,需要换行缩进，一般为四个空格：12345* 演示内容： &gt; 引用部分1 &gt; 引用部分2 &gt; 引用部分3 &gt; 引用部分4 代码块使用`包裹代码块，并声明代码块的语言，一般会带有相关的解析插件，对代码进行高亮处理，对代码进行着色。 超链接方括号显示说明，圆括号内显示网址， Markdown 编辑器会自动把它转成链接；123[我的博客](https://blog.csdn.net/limm33)[编程者联盟](https://github.com/limm33/ProgrammerLeague/blob/master/ProgrammerLeague.jpg)[个人博客](http://www.limingming.org) 演示： 图片图片和超连接语法比较像，可以在方括号前面加一个！就变成了引用图片了；1234![编程者联盟](url) 或者：![卡卡西](/Users/limm/Pictures/火影忍者/30381-106.jpg) 相对路径也可以(./path/*.jpg)这种形式 分割线使用 3 个以上 - 符号制作分割线：123分割线以上内容------------------分割线以下内容 演示： 表格markdown可以制作表格，方法也很简单例如：1233 | 3 | 3-|-|-3| 3| 3 以上为最基本的结构，‘3’代表你编辑的内容，第一行为表头，但是有的编辑器 - 需要多个，有的需要至少三个，所以布局可以尽量美观：123一列 | 第二列 | 第三列---------|---------------|---------- 值1 | 值2 | 值3 演示： 可以设置对齐方式,使用 ：添加在列的左边左对齐，右边为右对齐，两边都添加就是中间对齐：1234一列 | 第二列 | 第三列:---------|---------------:|:----------: 值1 | 值2 | 值3 值3 | 值4 | 值5 演示： 以上为总结的markdown的语法，希望对你的编写有所帮助。 联系我原来一直在CSDN编写博客我的博客我的微信公众号:编程者联盟我的 个人博客我的QQ群：115402375]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>介绍</tag>
        <tag>markdown</tag>
        <tag>语法</tag>
        <tag>怎么</tag>
        <tag>如何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下chromium源码编译笔记]]></title>
    <url>%2F2018%2F11%2F25%2F%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C%2Fmac%E4%B8%8Bchromium%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[作者 李明明转载请注明出处： http://limingming.org/index.php/2018/11/28/mac-compile-chromium/ 背景因为项目需要，需要对chromium进行了解，对chromium进行编译，在官网上可以通过：网址，找到各个平台相关详细的介绍，介绍文档这个是mac下编译chromium的讲解，本篇文章是针对于官方介绍文档的中文版，对其中编译过程中遇到的问题进行记录。 因为国内特殊的原因，谷歌相关的网络请求被墙掉了，所有需要配置科学上网能够翻墙的工具，我使用的是自己搭建的shadowsocks，shadowsocks搭建在这里就不细说了，由于需要chromium源码及depots_tools工具需要git命令下载，所以设置http_proxy，通过搭建好的shadowsocks可以通过下图中的方式获取到设置方式在终端中执行就行了，就可以在终端中请求被墙的网络地址了，具体设置git请求的设置和让终端走代理的设置大家可以百度一下，看一下详细的配置，自己设置一下， export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087; ​ 系统要求：64位mac,系统版本10.11+系统版本，屏幕左上角 苹果图标 -&gt; 关于本机 -&gt; 概览 Xcode 7.3+在 App Store搜索下载 OSX 10.10 SDK装完Xcode以后在终端输入下面的代码，如下图所示应该就可以了 1$ ls `xcode-select -p`/Platforms/MacOSX.platform/Developer/SDKs ​ 安装depot_tools用git复制 depot_tools 资源，如果一直下载不成功，检查一下http_proxy是否设置成功 1$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 把depot_tools加入路径,假设你放在/path/to/depot_tools路径下面，那么就在终端输入，不过这是临时的， 1$ export PATH=&quot;$PATH:/path/to/depot_tools&quot; 获取代码创建一个新的chromium文件夹并进入文件夹，你可以叫它别的名字，可以放在任意的位置，但是要保证路径没有空格 1$ mkdir chromium &amp;&amp; cd chromium 使用fetch来检出代码和依赖（这个代码我现在下大概是7.2GB，如果不想要所有的历史记录可以加–no-history，下载会快一点） 带历史记录的源码 1$ fetch chromium 不带历史记录的源码 1$ fetch --no-history chromium 会产生隐藏的.gclient的文件，如果下载失败，可以把这个文件删了重新执行 中间不会有任何的提示，请安静地等待~这种应该是下载成功了吧 ​然后你就会发现目录下面有src文件夹，进入文件夹，这里有提示install API keys ，但是对大多数的开发者不是必选项，所以就先跳过。在官网上没有详细介绍， 开始编译： 在编译之前要执行gclient sync和gclient runhooks，进入到src目录下，在src目录啊下编译，之前装了depot_tools，那么就可以用下面的代码开新建一个build的目录文件夹，（build可以换名字，但是out文件夹是必需的） gn gen out/build 更快地编译官网给了三个配置可以加快build，分别是is_debug，is_component_build，symbol_level，配置方式如下(关于配置的说明) 输入下面的命令行会打开一个配置文件 1gn args out/build 可以在文件里面输入配置，像下面展示的这样 123is_component_build = trueis_debug = falsesymbol_level = 0 其实他们应该保存在src/out/build/args.gn这边 输入下面的代码你能够查看所有可配置的参数以及他们的默认值 1gn args --list out/my_build 同时也可以通过install ccache ，在再次compile的时候会更快，会增量编译不会重复编译 build chromium使用Ninja来build chromium，这个过程会比较耗时，虽然很多人说等2个小时，我第一次编译用了5个小时 1$ ninja -C out/Default chrome 运行chromium输入 1$ out/Default/chrome Debugging 调试debug资料这里的意思是用图形化的环境不用在xcode里面配置Debugging in Xcode前面按照教程取消了crash的记录 最后的配置是在生成的文件夹下面找到products.xcodeproj，然后双击就会用xcode打开，然后配置scheme,第一次应该没有scheme配置，选择New Scheme，然后Info这边，Executable选择Chromium.app，‘ 然后启动chromium , Debug -》Attach to Processes -&gt; 选择Chomium程序 首先是第一个资料推荐苹果开发者阅读的Mac OS X Debugging Magic Technote重要提醒： 在xcode里面，为了让断点生效，Debugging面板中取消Load Symbols Lazily GYP_DEFINES的fast_build如果是1的话，那么你想要的断点可能拿不到,如果你去掉它，要重新运行gyp_chromium以及rebuild禁用ReportCrash，在终端输入man ReportCrash，然后找到这一行 ​ 12launchctl unload -w /System/Library/LaunchAgents/com.apple.ReportCrash.plistsudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.ReportCrash.Root.plist 调试渲染进程XCode本身不支持多于一个的进程，对子进程的支持也不友好，有两种方法应付。 (a)单进程运行chrome（不被推荐） CCache据说是加速recompilation的，他通过存储原来的compilation，当compilations相同的时候，能够有一个显著的加速，特别是切换分支的时候。首先用brew下载在环境变量里面配置 ，下面是临时的 1Export PATH=“$PATH:/usr/local/opt/ccache/libexec ccahe” 然后要让gn配置使用配置环境变量 123export CCACHE_CPP2=yesexport CCACHE_SLOPPINESS=time_macrosexport PATH=`pwd`/third_party/llvm-build/Release+Asserts/bin:$PATH 运行 ninja ninja -C out/Release chrome 推荐大家可以看一下《webkit技术内幕》 联系我原来一直在CSDN编写博客我的博客我的微信公众号:编程者联盟我的 个人博客我的QQ群：115402375]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>搭建</tag>
        <tag>源码</tag>
        <tag>chromium</tag>
        <tag>谷歌浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS下搭建Vue开发环境]]></title>
    <url>%2F2018%2F11%2F23%2FVue%2FMac-OS%E4%B8%8B%E6%90%AD%E5%BB%BAVue%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言原来一直学习使用React，现在因为工作的需要，对Vue进行学习和使用，现在比较流行的框架React,angular,vue，正好对于vue也进行些了解。 环境搭建 打开终端,安装brew 1usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装成功后，使用查看版本，验证是否安装成功1brew -v 安装node.js1brew install nodejs 也可以下载安装下载地址安装成功后，使用验证123node -v``` * 给nodejs目录赋权限 sudo chmod -R 777 /usr/local/lib/node_modules/1* 安装 淘宝镜像 （npm） npm install -g cnpm –registry=https://registry.npm.taobao.org12* 安装webpack cnpm install webpack -g12* 安装vue脚手架 npm install vue-cli -g12# 开始Vue 创建一个基于 webpack 模板的新项目$ vue init webpack my-project 这里需要进行一些配置，默认回车即可This will install Vue 2.x version of the template. For Vue 1.x use: vue init webpack#1.0 my-project ? Project name my-project? Project description A Vue.js project? Author runoob &#116;&#101;&#115;&#x74;&#64;&#114;&#x75;&#x6e;&#x6f;&#111;&#x62;&#x2e;&#x63;&#111;&#x6d;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated “my-project”. To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack1进入项目，安装并运行： $ cd my-project$ cnpm install$ cnpm run dev DONE Compiled successfully in 4388ms Listening at http://localhost:8080`]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>搭建</tag>
        <tag>Vue</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wordpress无法连接到FTP解决]]></title>
    <url>%2F2018%2F11%2F23%2F%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C%2Fwordpress%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0FTP%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题未能连接到FTP服务器IP:21 原因分析为了安全起见，wordpress会在安装插件或者主题时增加一层FTP验证 解决 修改wordpress 根目录下wp-config.php文件 1vi wordpress/wp-config.php 在文件最后添加一行内容 1define(&apos;FS_METHOD&apos;, &quot;direct&quot;); 重新试试就可以了！]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>解决</tag>
        <tag>wordpress</tag>
        <tag>无法连接</tag>
        <tag>FTP</tag>
        <tag>下载插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC-OS无法开机问题解决]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2FMAC-OS%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[作为一个自恋的程序员，我的imac升级了系统之后也变得傲娇起来，就是开机无法启动，进度条大约到五分之四的时候就卡住了，电脑也变黑屏了，之后进入了小圆圈一直转的无限循环的状态，暂时简称无限菊花状态。 问题导致原因原来mac系统为10.13.6，升级到了最新的系统之后10.14.8,虽然更新过程中没有任何问题，也能重新启动了电脑，有了新的黑色主题的imac并没有让我适应，总感觉还是原来的主题比较好，再不高兴之余骂了它的主题，顺便关了机，所以它就闹起了小脾气。 问题解决 首先想到的是“开机按住shift键进入安全模式，结果无法启动； 所以无耻的google了一下，按照说明开机无法启动的情况下，按住电源按钮十秒；钟，当然我很坚持的按住了15秒钟，隐隐若若的听到了“嗒”的一个内部的声音，感觉有什么东西被重置了的感觉，但是也是无济于事； 之后按照重置 Mac 上的系统管理控制器 (SMC),按照配置重置了smc，结果仍然不能开机； 按照重置 Mac 上的 NVRAM 或 PRAM重置了，原来电脑是静音状态，重置了之后生效了开机声音，可以听到开机声音了； 经过了以上几个步骤还是不能开机，所以我觉得应该弄点大招了，所以开机使用“command+r”的方式进入恢复模式选择磁盘工具，进行急救，修复了文件权限和磁盘，当然我没有进行任何磁盘破坏的事情，我很确信是因为升级导致的无法启动，所以磁盘急救完成重新开机竟然还是不行； 在磁盘急救不生效的情况下，用command+r进入恢复模式，重新安装系统，此种方式安装系统不会丢失任何文件和应用，可以放心安装，可能因为网络和时区的问题，导致无法正常安装，可以多试几次；但是重装覆盖系统之后还是不能开机。 在恢复模式下磁盘工具中抹掉磁盘，当然要备份好重要数据后抹掉磁盘，然后再执行安装系统，完成后就可以正常开机了。 说明以上几个步骤我在执行过程中可能没有生效，但是很多遇到这种情况的执行其中几步的时候都成功开机了，在万不得已的情况下可以抹掉磁盘重新安装系统。 联系我原来一直在CSDN编写博客我的博客，欢迎留言讨论，现在第一次更换为简书，竟然写的不是技术博客。我的微信公众号:编程者联盟 我的QQ群：115402375]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>解决</tag>
        <tag>苹果电脑</tag>
        <tag>无法开机</tag>
        <tag>转圈</tag>
      </tags>
  </entry>
</search>
