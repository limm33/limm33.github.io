<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[github删除仓库]]></title>
    <url>%2F2018%2F12%2F04%2FGit%2Fgithub%E5%88%A0%E9%99%A4%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[原文 介绍这片记录来自于好几年前自己在其他平台上写的博客，简单到只有几个步骤，但是因为删除github的仓库我的确找了好一会才找到怎么去删除，谨以此文献给还没有找到怎么删除仓库的程序员和非程序员. 进入你要删除的仓库 点击settings 找到删除仓库 输入你要删除仓库的名字 你就和你原来的仓库拜拜了 文章太短，图片来凑 提交代码我发布了如何删除github仓库的博客之后发现竟然有小姐姐留言说如果仓库是空的怎么删除，看来是刚创建了一个仓库删除不了空的仓库了，如果你不想在网页上创建一个文件上传的话，那就使用命令提交代码 清空缓存有些时候很多人误提交了忽略文件，当再次添加忽略文件内容进行忽略的时候不起左右，建议重新执行以下代码清空缓存区操作 1git rm -r --cached . 添加要提交的文件如果要全部提交的话可以使用 . 如果是某个文件可以单独添加声明具体文件 123git add .git commit -m "chore: 提交注释内容"git push 当然最好你添加了ssh密钥 文章太短，图片来凑]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>删除</tag>
        <tag>仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven工具包目录介绍]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2Fmaven%E5%B7%A5%E5%85%B7%E5%8C%85%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[maven的安装目录结构如下：12345678910111213binbootconflibLICENSE.txtNOTICE.txtREADME.txt 介绍 Bin 该目录包含了mvn运行的脚本，这些脚本用来配置Java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。其中mvn是基于UNIX平台的shell脚本，mvn.bat是基于Windows平台的bat脚本。在命令行输入任何一条mvn命令时，实际上就是在调用这些脚本。该目录还包含了mvnDebug和mvnDebug.bat两个文件，同样，前者是UNIX平台的shell脚本，后者是windows的bat脚本。那么mvn和mvnDebug有什么区别和关系呢？打开文件我们就可以看到，两者基本是一样的，只是mvnDebug多了一条MAVEN_DEBUG_OPTS配置，作用就是在运行Maven时开启debug，以便调试Maven本身。此外，该目录还包含m2.conf文件，这是classworlds的配置文件。 Boot 该目录只包含一个文件，以maven 3.0为例，该文件为plexus-classworlds-2.2.3.jar。plexus-classworlds是一个类加载器框架，相对于默认的java类加载器，它提供了更丰富的语法以方便配置，Maven使用该框架加载自己的类库。更多关于classworlds的信息请参考http://classworlds.codehaus.org/。对于一般的Maven用户来说，不必关心该文件。 Conf该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为。一般情况下，我们更偏向于复制该文件至~/.m2/目录下（这里~表示用户目录），然后修改该文件，在用户范围定制Maven的行为。 Lib 该目录包含了所有Maven运行时需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如mavn-core-3.0.jar、maven-model-3.0.jar之类的文件，此外这里还包含一些Maven用到的第三方依赖如common-cli-1.2.jar、google-collection-1.0.jar等等。可以说，这个lib目录就是真正的Maven。关于该文件，还有一点值得一提的是，用户可以在这个目录中找到Maven内置的超级POM， 其他： LICENSE.txt记录了Maven使用的软件许可证Apache License Version 2.0； NOTICE.txt记录了Maven包含的第三方软件；而README.txt则包含了Maven的简要介绍，包括安装需求及如何安装的简要指令等等。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>工具包</tag>
        <tag>目录</tag>
        <tag>介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven核心概念]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2FMaven%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[原文 介绍Maven作为一个构建工具由于遵循了约定优于配置的原则，只要编写比Ant所需少得多的脚本就能实现同样的构建。并且Maven还有很多Ant没有的高级特性，例如依赖管理等，这一切使得Maven不仅是构建工具，更是项目管理工具，并越发流行起来。 Maven拥有三套相互独立的生命周期，它们分别为clean，default和site。 Clean Lifecycle在进行真正的构建之前进行一些清理工作。Default Lifecycle构建的核心部分，编译，测试，打包，部署等等。Site Lifecycle生成项目报告，站点，发布站点。每个生命周期包含一些阶段，这些阶段是有顺序的，并且后面的阶段依赖于前面的阶段，用户和Maven最直接的交互方式就是调用这些生命周期阶段。较之于生命周期阶段的前后依赖关系，三套生命周期本身是相互独立的，用户可以仅仅调用clean生命周期的某个阶段，或者仅仅调用default生命周期的某个阶段，而不会对其他生命周期产生任何影响。 以下是我列出的百度百科中对maven的使用介绍，可见maven的使用是很简单的： 1234567891011121314151617181920212223mvn archetype:create创建Maven项目mvn compile编译源代码mvn deploy发布项目mvn test-compile编译测试源代码mvn test运行应用程序中的单元测试mvn site生成项目相关信息的网站mvn clean清除项目目录中的生成结果mvn package根据项目生成的jarmvn install在本地Repository中安装jarmvn eclipse:eclipse生成eclipse项目文件mvn jetty:run启动jetty服务mvn tomcat:run启动tomcat服务 正因为我们使用maven的方便，这导致了开发人员只是单纯的使用几个命令，而对Maven不求详细的了解，上述命令中有些有冒号，而有些没有，有冒号的命令是执行指定的插件，而没有冒号的命令是执行按照Maven生命周期里来执行的。那究竟生命周期又是什么呢？ 生命周期Maven的生命周期是对所有的构建过程进行抽象和统一。Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际的工作，生命周期只是定义了一系列的阶段，并确定这些阶段的执行顺序。而在执行这些阶段时，实际的工作还是由插件来完成的。 上面我们也说到过，生命周期包含一些阶段，这些阶段是有顺序的，并且后面的阶段依赖于前面的阶段，用户和Maven最直接的交互方式就是调用这些生命周期阶段。 clean生命周期 clean生命周期的目的是清理项目，它包含三个阶段： 1）pre-clean 执行一些清理前需要完成的工作。 2）clean 清理上一次构建生成的文件。 3）post-clean 执行一些清理后需要完成的工作。 default生命周期 default生命周期定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分，它包含的阶段如下： 1） validate 验证项目是否正确和所有需要的相关资源是否可用 2） initialize 初始化构建 3） generate-sources 4) process-sources 处理源代码 5） generate-resources 6) process-resources 处理项目主资源文件。对src/main/resources目录的内容进行变量替换等工作后，复制到项目输出的主classpath目录中。 7） compile 编译项目的主源代码 8） process-classes 9) generate-test-sources 10) process-test-sources 处理项目测试资源文件 11）generate-test-resources 12) process-test-resources 处理测试的资源文件 13）test-compile 编译项目的测试代码 14）process-test-classes 15) test 使用单元测试框架运行测试，测试代码不会被打包或部署 16）prepare-package 做好打包的准备 17）package 接受编译好的代码，打包成可发布的格式 18) pre-integration-test 19) integration-test 20) postintegration-test 21) verify 22) install 将包安装到Maven本地仓库，供本地其他Maven项目使用 23）deploy 将最终的包复制到远程仓库，供其他开发人员和Maven项目使用 site生命周期 site生命周期的目的是建立和发布项目站点，Maven能够基于POM所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。该生命周期包含如下阶段： 1）pre-site 执行一些在生成项目站点之前需要完成的工作 2）site 生成项目站点文档 3）post-site 执行一些在生成项目站点之后需要完成的工作 4）site-deploy 将生成的项目站点发布到服务器上 用户在mvn命令后可以指定三个生命周期中的任何阶段，则Maven会按以下逻辑执行：首先会得到该阶段所属生命周期，从该生命周期中的第一个阶段开始按顺序执行，直至该阶段本身。例如执行mvnclean命令会依次执行clean生命周期中的pre-clean阶段及clean阶段。mvn命令后可以指定多个阶段，Maven会按照输入的顺序依次执行，每次执行都会按照之前描述的逻辑执行 projectobject Modelpom是一个xml，是maven工作的基础，执行任务时，maven会到项目根目录下读取pom.xml获得需要的配置信息pom文件中包含了项目的信息和maven build项目所需的配置信息，通常有项目信息(如版本、成员)、项目的依赖、插件和goal、build选项等等pom是可以继承的，通常对于一个大型的项目或是多个module的情况，子模块的pom需要指定父模块的pom Artifact &amp; RepositoriesArtifact：一个项目将要产生的文件，可以是jar文件，源文件，二进制文件，war文件，甚至是pomRepositories是用来存储Artifact的Repositories分为本地仓库和远程仓库，远程仓库是指远程服务器上用于存储Artifact的仓库，本地仓库是指本机存储Artifact的仓库 Maven坐标Maven坐标是一组可以惟一标识构件的三元组值groupId，代表构件的实体或组织例如：org.inspur.loushangartifactId,实际的构件的名称，例如frameworkversion，该构件件的版本号packaging ：定义Maven项目打包的方式，首先，打包方式通常与所生成构件的文件扩展名对应，如上例中的packaging为jar,最终的文件名为my-app-0.0.1-SNAPSHOT.jar。也可以打包成war, ear等。当不定义packaging的时候，Maven 会使用默认值jar classifier: 该元素用来帮助定义构建输出的一些附件。附属构件与主构件对应，如上例中的主构件为my-app-0.0.1-SNAPSHOT.jar,该项目可能还会通过一些插件生成如my-app-0.0.1-SNAPSHOT-javadoc.jar,my-app-0.0.1-SNAPSHOT-sources.jar, 这样附属构件也就拥有了自己唯一的坐标]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>概念</tag>
        <tag>核心</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven配置使用nexus私服]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2FMaven%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8nexus%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[[原文](http://limingming.org/index.php/2018/12/03/maven-use-nexus/） 在项目中的pom中：123456789101112131415&lt;!-- 配置私服使用信息 --&gt;&lt;repositories&gt;&lt;repository&gt;&lt;id&gt;nexus-jar&lt;/id&gt;&lt;name&gt;Team Nexus jar Repository&lt;/name&gt;&lt;url&gt;http://IP:host/nexus/content/groups/inspur-loushang/&lt;/url&gt;&lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt;&lt;pluginRepository&gt;&lt;id&gt;nexus-plugin&lt;/id&gt;&lt;name&gt;Team Nexus plugin Repository&lt;/name&gt;&lt;url&gt;http://IP:host/nexus/content/groups/inspur-loushang/&lt;/url&gt;&lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 在setting.xml中（1）在mirrors中配置唯一镜像： 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;jszx&lt;/name&gt; &lt;url&gt;http://IP:host/nexus/content/groups/inspur-jszx/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; （2）在profiles中配置 12345678910111213141516171819202122232425262728293031&lt;profiles&gt;&lt;!-- 添加私服配置 --&gt; &lt;profile&gt; &lt;id&gt;myprofile&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://IP:host/nexus/content/groups/inspur-jszx/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://IP:host/nexus/content/groups/inspur-jszx/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; 在profiles外添加激活配置： 123&lt;activeProfiles&gt; &lt;activeProfile&gt;myprofile&lt;/activeProfile&gt; &lt;/activeProfiles&gt; activeProfile可以有多个.]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>使用私服</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装nexus]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2F%E5%AE%89%E8%A3%85nexus%2F</url>
    <content type="text"><![CDATA[原文 介绍私服不是Maven的核心概念，它仅仅是一种衍生出来的特殊的Maven仓库。如果没有私服，我们所需的所有构件都需要通过maven的中央仓库和第三方的Maven仓库下载到本地，而一个团队中的所有人都重复的从maven仓库下载构件无疑加大了仓库的负载和浪费了外网带宽，如果网速慢的话，还会影响项目的进程。很多情况下项目的开发都是在内网进行的，连接不到maven仓库怎么办呢？开发的公共构件怎么让其它项目使用？这个时候我们不得不为自己的团队搭建属于自己的maven私服，这样既节省了网络带宽也会加速项目搭建的进程，当然前提条件就是你的私服中拥有项目所需的所有构件。 安装NexusNexus是典型的JavaWeb应用，它有两种安装包，一种是包含Jetty容器的Bundle包，另一种是不包含Web容器的war包。 下载Nexus 官网http://www.sonatype.org/nexus/ 下载最新的Nexus。 Bundle方式安装Nexus a.首先看下解压后的目录，结构： 解压后存在两个文件夹：nexus-2.4.0-01（不同版本版本号不同）和sonatype-work。 nexus-2.4.0-01: 该目录包含了Nexus运行所需要的文件，如启动脚本、依赖jar包等。 sonatype-work：该目录包含Nenus生成的配置文件、日志文件、仓库文件等。 第一个目录是运行Nexus必须的，而第二个不是必须的，Nexus会在运行的时候动态创建该目录。 b.配置Path，启动Nexus（在windows操作系统上） 首先在环境变量path下加入如下地址：C:\nexus\nexus-2.6.2-01-bundle\nexus-2.6.2-01\bin；之后在cmd下启动Nexus服务： 启动成功后，可以打开打开浏览器访问：http://localhost:8081/nexus 就可以看到Nexus的界面了。 8081为默认的端口号，要修改端口号可进入nexus-2.1.2-bundle\nexus-2.1.2\conf\打开nexus.properties文件，修改application-port属性值就可以了 这时你可以单击界面右上角的Login进行登录，Nexus默认管理用户名和密码为admin/admin123。 b.1在linux上切换到/opt/nexus/nexus-2.14.0-01/bin目录下 存在nexus及nexus.bat文件，可以使用./nexus start 启动nexus，这时候可能会报错。 这时候提示： 123WARNING – NOTRECOMMENDED TO RUN AS ROOTIf you insist running as root, then set theenvironment variable RUN_AS_USER=root before running this script. 大概意思就是要在环境配置export RUN_AS_USER=root，临时配置 在命令行下输入： 1export RUN_AS_USER=root 然后执行，就不会再提示了 1./nexus start 也可以在系统里面永久配置 1vi /etc/profile 加入export RUN_AS_USER=root Nexus的索引这时你使用Nexus搜索插件得不到任何结果，为了能够搜索Maven中央库，首先需要设置Nexus中的MavenCentral仓库下载远程索引。 单击左边导航栏的Repositories，可以link到这个页面，选择Central，点击Configuration，里面有一个DownloadRemote Indexes配置，默认状态是false，将其改为true，‘Save’后，单击Administration==&gt; ScheduledTasks,就有一条更新Index的任务，这个是Nexus在后天运行了一个任务来下载中央仓库的索引。由于中央仓库的内容比较多，因此其索引文件比较大，Nexus下载该文件也需要比较长的时间。请读者耐心等待把。如果网速不好的话，可以使用其他人搭建好的的Nexus私服。后面会介绍 配置Maven从Nexus下载构件 在POM中配置Nexus私服，这样的配置只对当前的Maven项目有效。 12345678910111213&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Repository&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 在settings.xml中配置profile元素，这样就能让本机所有的Maven项目都使用自己的Maven私服。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt;&lt;/profiles&gt;``` 以上配置所有Maven下载请求都仅仅通过Nexus，以全面发挥私服的作用。# 部署构件到Nexus1. 在POM中配置```xml&lt;project&gt; ... &lt;distributionManagement&gt;&lt;snapshotRepository&gt; &lt;id&gt;user-snapshots&lt;/id&gt; &lt;name&gt;User Project SNAPSHOTS&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/MyUserReposSnapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;repository&gt; &lt;id&gt;user-releases&lt;/id&gt; &lt;name&gt;User Project Release&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/MyUserReposRelease/&lt;/url&gt; &lt;/repository&gt; &lt;/distributionManagement&gt; ...&lt;/project&gt; settings.xml中配置认证信息，Nexus的仓库对于匿名用户是只读的。 123456789101112131415&lt;servers&gt; &lt;server&gt; &lt;id&gt;user-snapshots&lt;/id&gt; &lt;username&gt;lb&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;user-releases&lt;/id&gt; &lt;username&gt;lb&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>maven</tag>
        <tag>nexus</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍maven私服-Nexus]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2F%E4%BB%8B%E7%BB%8Dmaven%E7%A7%81%E6%9C%8D-Nexus%2F</url>
    <content type="text"><![CDATA[原文 什么是私服私服是架设在局域网的一种特殊的远程仓库，目的是代理远程仓库及部署第三方构件。有了私服之后，当Maven 需要下载构件时，直接请求私服，私服上存在则下载到本地仓库；否则，私服请求外部的远程仓库，将构件下载到私服，再提供给本地仓库下载。 以下是有无私服的对比： Nexus下载与安装 Nexus安装的先决条件不管是NexusOpen Source还是Nexus Professional，他们只有一个先决条件就是必须有一个JavaRuntime Environment，且必须是Java 5或更高。 下载Nexus：Nexus有2个版本，Nexus Open Source 和 NexusProfessional。NexusOpen Source是可基于EPL协议免费使用修改分发的全功能仓库管理系统。Nexus Professional主要用于需要复杂大型企业或组织。 本文只介绍NexusOpen Source，下文简称Nexus。Nexus下载地址，有完整版，有war版。前者可以单独运行为一个基于jetty的服务，后者是运行在ServletConstainer的Web应用。 安装Nexus安装Nexus非常简单。解压下载的文件到任意目录，不过要小心权限问题已经Windows下带空格文件夹引起的问题。然后配置NEXUS_HOME。解压出来的目录下除了nexus外，还有一个sonatype-work文件夹。这个文件夹包含了所有nexus的仓库以及配置数据，这么做使得更加容易更新到新版的nexus。当然，这个目录的路径也能通过NEXUS_HOME/conf/nexus.properties修改。 运行Nexus当你运行Nexus时，你实际运行的是一个运行在0.0.0.0:8081的web server。Nexus运行在一个Jetty的servlet容器内，然后通过一个本地的封装服务Tanuki Java Service Wrapper来启动。它可以通过配置将nexus运行为一个unix或者windows的一个服务。bin目录下的nexus或者nexus.bat就是服务的起点，通过你的系统来选择对应的版本。 启动后，你就能通过浏览器访问http://localhost:8081/nexus 配置Nexus为服务 当你把Nexus用于生产环境时，你应该将Nexus配置为一个服务，让他在后台运行以及在服务器重启后恢复服务。方法是 bin/nexus start 常用功能Nexus常用功能就是：指定私服的中央地址、将自己的Maven项目指定到私服地址、从私服下载中央库的项目索引、从私服仓库下载依赖组件、将第三方项目jar上传到私服供其他项目组使用。开启Nexus服务后访问url地址http://localhost:8081/nexus, (推荐使用自己的ip地址)，之后登录系统，用户名密码分别是：admin/admin123. 仓库类别：Hosted代表宿主仓库，用来发布一些第三方不允许的组件，其中自带仓库类型中3rd一般用来发布第三方无法在中央仓库获取的jar包，比如oracle的jdbc的jar包，Releases一般存放公司内的封版的项目，Snapshots用来存放正在开发的版本。Proxy代表代理远程的仓库，最典型的就是Maven官方中央仓库、JBoss仓库等等。如果构建的Maven项目本地仓库没有依赖包，那么就会去这个代理站点去下载，那么如果代理站点也没有此依赖包，就回去远程中央仓库下载依赖，这些中央仓库就是proxy。代理站点下载成功后再下载至本机。笔者认为，其实Maven这个自带的默认仓库一般情况下已经够大多数项目使用了。group 仓库是一个“仓库组”，为开发人员便于开发设置的仓库，可以将多个已存在的其他仓库配置其中提供给大家使用，在nexus中配置的时候注意的是左侧是配置仓库组使用的仓库。virtual仓库是用于提供中央仓库中M1格式的发布版本的构件镜像仓库，即在当此M2仓库中为M1格式的仓库构件缓存提供出来的。 maven项目索引: 下载Maven项目索引，项目索引是为了使用者能够在私服站点查找依赖使用的功能例如：就可以检索出它的相关信息，包括怎么配置依赖信息。我们要想使用这个私服仓库，先在项目pom中配置相关私服信息 使用配置以下为在pom中声明指定使用私服的方式： 指定仓库 12345678910111213&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;nexus&lt;/name&gt; &lt;url&gt;http://192.168.1.103:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 指定插件仓库 12345678910111213&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;nexus&lt;/name&gt; &lt;url&gt;http://192.168.1.103:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; 这样只有本项目才在私服下载组件 这样这个Maven项目构建的时候会从私服下载相关依赖，当构建项目的时候，maven会从私服将构件下载到本地仓库，当然这个配置仅仅是在此项目中生效，对于其他项目还是不起作用。如果相对Maven的其他项目也生效的话。需要修改全局的settings.xml文件。 修改settings.xml为 12345678910111213141516171819202122232425262728293031&lt;profiles&gt;……………&lt;profile&gt; &lt;id&gt;myprofile&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://10.110.13.14:8081/nexus/content/groups/inspur-jszx/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://10.110.13.14:8081/nexus/content/groups/inspur-jszx/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt;……………&lt;profiles&gt; 追加激活profile 123&lt;activeProfiles&gt; &lt;activeProfile&gt;central&lt;/activeProfile&gt; &lt;/activeProfiles&gt; 之后所有本机的Maven项目就在私服下载组件。 项目的发布: 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;user-release&lt;/id&gt; &lt;name&gt;UserProject Release&lt;/name&gt; &lt;url&gt;http://192.168.1.103:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;user-snapshots&lt;/id&gt; &lt;name&gt;UserProject SNAPSHOTS&lt;/name&gt; &lt;url&gt;http://192.168.1.103:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 注意配置了还是发布项目到私服失败，原因为没有权限，会出现401错误码，原因就是权限不够。 配置权限在settings.xml 注意Respository中的id一定要和server下的id一致，切记！！否则出现权限问题。 然后运行发布 1mvn clean deploy 在控制台发布成功 然后进入到私服上的仓库中，看一下确实存在刚刚发布的项目 手动上传用admin管理员权限用户登录，找到相应的上传配置，分别选中填写信息就最后Upload构件就可以了]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>介绍</tag>
        <tag>nexus</tag>
        <tag>私服</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven项目命名规范]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2FMaven%E9%A1%B9%E7%9B%AE%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[原文 官方文档介绍Guide to naming conventions on groupId, artifactId and versiongroupId will identify your project uniquely across all projects, so we need to enforce a naming schema. It has to follow the package name rules, what means that has to be at least as a domain name you control, and you can create as many subgroups as you want. Look at More information about package names.eg. org.apache.maven, org.apache.commons A good way to determine the granularity of the groupId is to use the project structure. That is, if the current project is a multiple module project, it should append a new identifier to the parent’s groupId. eg. org.apache.maven, org.apache.maven.plugins, org.apache.maven.reporting artifactId is the name of the jar without version. If you created it then you can choose whatever name you want with lowercase letters and no strange symbols. If it’s a third party jar you have to take the name of the jar as it’s distributed.eg. maven, commons-math version if you distribute it then you can choose any typical version with numbers and dots (1.0, 1.1, 1.0.1, …). Don’t use dates as they are usually associated with SNAPSHOT (nightly) builds. If it’s a third party artifact, you have to use their version number whatever it is, and as strange as it can look.eg. 2.0, 2.0.1, 1.3.1 以上内容是maven官网文档命名约定指南 总结groupId:定义当前Maven项目隶属的实际项目，例如org.sonatype.nexus，此id前半部分org.sonatype代表此项目隶属的组织或公司，后部分代表项目的名称，如果此项目多模块话开发的话就子模块可以分为org.sonatype.nexus.plugins和org.sonatype.nexus.utils等。特别注意的是groupId不应该对应项目隶属的组织或公司，也就是说groupId不能只有org.sonatype而没有nexus。 例如：我建立一个项目，此项目是此后所有项目的一个总的平台，那么groupId应该是org.limingming.projectName,projectName是平台的名称，org.limingming是代表我个人的组织，如果以我所在的浪潮集团来说的话就应该是com.inspur.loushang。 artifactId是构件ID，该元素定义实际项目中的一个Maven项目或者是子模块，如上面官方约定中所说，构建名称必须小写字母，没有其他的特殊字符，推荐使用“实际项目名称－模块名称”的方式定义，例如：spirng-mvn、spring-core等。 推荐格式：使用实际项目名称作为artifactId的前缀，紧接着为模块名称举例：nexus-indexer、spring-mvc、hibernate-c3po……这些id都是以实际项目名称作为前缀，然后接着一个中划线，再紧跟项目的模块名称，默认情况下maven会在artifactId添加version作为最后生成的名称。例如：spirng-mvn-2.0.0.jar]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>命名</tag>
        <tag>规范</tag>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven清除LastUpdated文件]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2FMaven%E6%B8%85%E9%99%A4LastUpdated%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[原文 介绍maven仓库中的某个构件如果因为网络或者其他的原因，没有下载成功或者下载被中断，将会出现一个LastUpdated的文件，这个时候，就算网络好了，也不能正常使用这个构件。 在linux系统上可以切换到仓库的目录下执行： 1find ./ -name "*.lastUpdated" -exec grep -q "Could not transfer" &#123;&#125; \; -print -exec rm &#123;&#125; \; 在windows系统下可以保存到后缀为bat的文件中修改仓库的目录执行：12345678rem 这里写你的仓库路径set REPOSITORY_PATH=E:\storage\maven\repositoryrem 正在搜索...for /f "delims=" %%i in ('dir /b /s "%REPOSITORY_PATH%\*lastUpdated*"') do ( del /s /q %%i)rem 搜索完毕pause 执行上面的命令后删掉本地仓库的.lastupdate文件，重新构建，必要的情况可以开vpn下载。某些一直报错的jar包，校验MD5，不对的请删掉重新构建 错误总结Maven项目导入eclipse中很多时候都出现报错的情况，出错的原因大致可以分为下列几种： JDK版本不一致 网络问题无法下载，可以尝试开vpn下载 私有jar包]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>清除</tag>
        <tag>lastUpdated</tag>
        <tag>脚本</tag>
        <tag>无法构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven安装jar包到仓库]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2FMaven%E5%AE%89%E8%A3%85jar%E5%8C%85%E5%88%B0%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[原文 介绍废话就不说了： 1mvn install:install-file –Dfile=loushang-home-6.0.RELEASE.jar –DgroupId=org.loushang.framework –DartifactId=loushang-home –Dversion=6.0.RELEASE –Dpackaging=jar python脚本批量上传Jar包到私服123456789101112131415161718192021222324252627from xml.etree.ElementTree import Element, SubElement, tostring,ElementTreeimport globimport osdef mvn_script(filename): return "mvn deploy:deploy-file -DrepositoryId=open2-baidu -Durl=http://10.100.10.131:8119/nexus-2.3.0-04/content/repositories/open2-baidu -DgroupId=com.pzoom -DartifactId="+filename[0:len(filename)-4]+" -Dversion=1.0 -Dpackaging=jar -Dfile="+filenamedef writeDependency(filename): dependencies = Element("dependencies") dependency = SubElement(dependencies,"dependency") groupId = SubElement(dependency, "groupId") groupId.text = "com.pzoom" artifactId = SubElement(dependency, "artifactId") artifactId.text = filename[0:len(filename)-4] version = SubElement(dependency, "version") version.text="1.0" ElementTree(dependencies).write("out.xml")files = glob.glob('*.jar')for file in files: writeDependency(file) print(file) os.system(mvn_script(file)) print('upload success') print('delete the file : '+file) os.remove(file) 中间的参数部分可以自行更改。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>仓库</tag>
        <tag>Maven</tag>
        <tag>安装</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven多web模块打包问题]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2Fmaven%E5%A4%9Aweb%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原文 介绍在项目开发中可能会遇到这种那种的maven问题，尤其是在企业原有的开发模式转换到mavne方式进行开发的时候，以下就列出在企业项目拆分的过程中总结的maven多个子web模块的整合遇到的问题。 在各个子模块中可以添加，注意relativePath，在子模块中设置，可以在项目构建时先在本地项目中查找，使用../.. ，然后在去仓库和私服查找父pom: 123456&lt;parent&gt; &lt;groupId&gt;com.founder.fix.fixflow&lt;/groupId&gt; &lt;artifactId&gt;fixflow-root&lt;/artifactId&gt; &lt;version&gt;5.0&lt;/version&gt; &lt;relativePath&gt;../..&lt;/relativePath&gt; &lt;/parent&gt; 在依赖中添加对另一个web模块打成jar包的依赖，使用war，如下： 123456&lt;dependency&gt; &lt;groupId&gt;org.loushang.framework&lt;/groupId&gt; &lt;artifactId&gt;loushang-framework&lt;/artifactId&gt; &lt;version&gt;$&#123;loushang-framework.version&#125;&lt;/version&gt; &lt;type&gt;war&lt;/type&gt;&lt;/dependency&gt; 可以声明多个依赖； build中添加相关设置，如果不添加的话可以设置是否：123456789101112131415161718192021222324&lt;build&gt; &lt;finalName&gt;lousing&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 合并多个war --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;packagingExcludes&gt;WEB-INF/web.xml&lt;/packagingExcludes&gt; &lt; overlays&gt; &lt;!-- 声明合并war --&gt; &lt;overlay&gt; &lt;groupId&gt;com.founder.fix.fixflow&lt;/groupId&gt; &lt;artifactId&gt;fixflow-webapp-taskcenter&lt;/artifactId&gt; &lt;excludes&gt; &lt;!-- 声明排除war包中的部分 --&gt; &lt;exclude&gt;*/web.xml,WEB-INF/lib/*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/overlay&gt; &lt;/overlays&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 注意在被合并的子模块没有web.xml部分，要声明： 1234567891011121314151617181920212223&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;&lt;version&gt;2.6&lt;/version&gt;&lt;configuration&gt; &lt;!—－ 设置将其他文件打包到war包 --&gt;&lt;webResources&gt;&lt;resource&gt;&lt;directory&gt;$&#123;basedir&#125;/../commonFiles/jsp&lt;/directory&gt;&lt;!-- &lt;directory&gt;src/main/resources&lt;/directory&gt; --&gt;&lt;filtering&gt;true&lt;/filtering&gt; &lt;targetPath&gt;/&lt;/targetPath&gt;&lt;/resource&gt;&lt;/webResources&gt;&lt;!-- 解决web模块中没有web.xml报错的问题 --&gt;&lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;!-- 解决打包时候排除空文件不打包 --&gt;&lt;includeEmptyDirectories&gt;true&lt;/includeEmptyDirectories&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;/plugins&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>模块</tag>
        <tag>打包</tag>
        <tag>问题</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven的Scope类型及引用本地jar包方式]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2FMaven%E7%9A%84Scope%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0jar%E5%8C%85%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原文 介绍Maven配置中我们经常会配置使用Scope，scope的默认值是compile，在开发过程中很多时候会用到引用本地jar包的方式，通过scope的一个配置也能实现引用本地jar包，通过英文翻译我们也能知道，这个配置声明的是当前“构件”能作用的范围是在哪儿，scope共有5个值，下面我们分别看一下。 scope的value compile这是默认范围，如果未指定则使用。编译依赖项在项目的所有类路径中都可用。此外，这些依赖项能被传递到依赖的项目，也就是说能作用在classpath范围内，声明为compile的构件也会被打包到应用中。 test此范围表示正常使用应用程序不需要依赖关系，并且仅适用于测试编译和执行阶段。此范围不具有传递性。scope为test表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的就是junit。 runntimerunntime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比跳过了编译而已，oracle jdbc驱动包就是一个很好的例子，一般scope为runntime。另外runntime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。 provided这个和编译很相似，provided意味着打包的时候可以不用打包进去，jdk或者容器(Web Container)会这个提供这个构件的依赖，意味着容器内会包含这个构件，例如servlet.jar在tomcat中。事实上该依赖，理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包的时候被排除掉了。此范围仅在编译和测试类路径中可用，并且不可传递。 system此范围与提供的类似，从参与度来说，和provided相同，被依赖项不会从maven仓库找，而是在本地文件系统找，一定需要配合systemPath属性使用。 scope的依赖传递A–&gt;B–&gt;C。当前项目为A，A依赖于B，B依赖于C。知道B在A项目中的scope，那么怎么知道C在A中的scope呢？答案是：当C是test或者provided时，C直接被丢弃，A不依赖C；否则A依赖C，C的scope继承于B的scope。 PS：还有一个补充项import此范围仅在部分中的pom类型的依赖项上受支持。它指示要使用指定POM的部分中的有效依赖项列表替换的依赖项。由于它们被替换，具有导入范围的依赖性实际上不参与限制依赖性的传递性。 参考地址参考地址中内容如下： 123456789101112131415There are 6 scopes available:compileThis is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated to dependent projects.providedThis is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope provided because the web container provides those classes. This scope is only available on the compilation and test classpath, and is not transitive.runtimeThis scope indicates that the dependency is not required for compilation, but is for execution. It is in the runtime and test classpaths, but not the compile classpath.testThis scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases. This scope is not transitive.systemThis scope is similar to provided except that you have to provide the JAR which contains it explicitly. The artifact is always available and is not looked up in a repository.importThis scope is only supported on a dependency of type pom in the &lt;dependencyManagement&gt; section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM&apos;s &lt;dependencyManagement&gt; section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency.Each of the scopes (except for import) affects transitive dependencies in different ways, as is demonstrated in the table below. If a dependency is set to the scope in the left column, transitive dependencies of that dependency with the scope across the top row will result in a dependency in the main project with the scope listed at the intersection. If no scope is listed, it means the dependency will be omitted. 配置应用本地jar包有一次由于私服出了问题，我又不想将jar包安装到本地仓库，所以想直接引用本地的jar包，所以就使用了接下来的设置。这样有个问题是我们可以声明用到此jar包进行编译构建，但是最终的结果中不会将此jar包打包到项目中，也不会将此jar包安装到仓库里，我觉得如果非要采用这种方式进行引用构建的话，将jar包放到webapp下WEBINF下的lib文件夹中引用，通过${project.basedir}这个配置获取项目的路径，这样就会将jar包构建到结果项目中。 12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.ibm&lt;/groupId&gt; &lt;artifactId&gt;jms&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/lib/jms.jar&lt;/systemPath&gt; &lt;/dependency&gt; 我们声明了scope为system， 它使用起来和provided差不多，即此依赖由系统提供，但是与provided有点不同的是，它需要显式的使用systemPath指定lib所在的路径，如上systemPath。 其他当然我们也可以通过配置插件打包其他目录文件到war包的方式发布构件，配置如下，看是否可以借鉴一下： 12345678910111213141516&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;&lt;configuration&gt;&lt;webResources&gt;&lt;resource&gt;&lt;directory&gt;$&#123;project.basedir&#125;/lib&lt;/directory&gt;&lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt;&lt;filtering&gt;true&lt;/filtering&gt;&lt;includes&gt;&lt;include&gt;**/*.jar&lt;/include&gt;&lt;/includes&gt;&lt;/resource&gt;&lt;/webResources&gt;&lt;/configuration&gt;&lt;/plugin&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>scope</tag>
        <tag>类型</tag>
        <tag>system</tag>
        <tag>本地</tag>
        <tag>jar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven多WEB模块打包排除jar包冲突的配置建议]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2FMaven%E5%A4%9AWEB%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%8E%92%E9%99%A4jar%E5%8C%85%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[原文 前提在原有的web项目基础上拆分出了多个web项目，后台代码还是在各个web模块中，现在的需求是要合并多个web模块整合到一个war中部署。 配置建议新建打包的web模块用以合并多个web模块项目，在pom中声明合并打包的各个模块，例如要合并A模块和B模块，如下： 123456789101112131415161718192021222324252627&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;A&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;type&gt;war&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;A&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;B&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;type&gt;war&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;B&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 我们需要在合并打包的项目中依赖要合并的各个war包和各个模块的pom。 排除各个模块的lib： 排除各个模块的lib 123456789101112131415161718192021222324252627282930&lt;build&gt;&lt;finalName&gt;B&lt;/finalName&gt;&lt;plugins&gt; &lt;!-- 合并多个war --&gt;&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;&lt;version&gt;2.6&lt;/version&gt;&lt;configuration&gt;&lt;overlays&gt; &lt;!-- 声明合并war --&gt;&lt;overlay&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;A&lt;/artifactId&gt;&lt;excludes&gt;&lt;!-- 声明排除war包中的部分 --&gt;&lt;exclude&gt;WEB-INF/lib/*&lt;/exclude&gt;&lt;/excludes&gt;&lt;/overlay&gt;&lt;/overlays&gt;&lt;overlays&gt; &lt;!-- 声明合并war --&gt;&lt;overlay&gt;&lt;groupId&gt;com.inspur.test&lt;/groupId&gt;&lt;artifactId&gt;B&lt;/artifactId&gt;&lt;excludes&gt;&lt;!-- 声明排除war包中的部分 --&gt;&lt;exclude&gt;WEB-INF/lib/*&lt;/exclude&gt;&lt;/excludes&gt;&lt;/overlay&gt;&lt;/overlays&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 大家有哪些多模块开发构建的规范，很希望能给出你的建议到原文评论，谢谢。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>排除</tag>
        <tag>多模块</tag>
        <tag>web</tag>
        <tag>合并</tag>
        <tag>冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在maven的web项目中内嵌tomcat插件执行war包]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2F%E5%9C%A8maven%E7%9A%84web%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%86%85%E5%B5%8Ctomcat%E6%8F%92%E4%BB%B6%E6%89%A7%E8%A1%8Cwar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[原文地址 环境要求Unix System\windwos\macOSJDK 1.7+Maven 3.0 or later 我测试的编译环境是：macOS10.11.6和windows10jdk1.8/jdk1.7Maven 3.3.9 我的本机开发环境：MacOS 10.11.6eclipse Mars.2 在pom中配置tomcat-maven-plugin123456789101112131415161718192021222324&lt;project&gt; ... &lt;packaging&gt;war&lt;/packaging&gt; ... &lt;build&gt; ... &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat6-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; ... &lt;/plugins&gt; ... &lt;/build&gt; ...&lt;/project&gt; 运行war包执行 tomcat7:run-war或者tomca6:run-war 如果想要修改其他配置可以在标签下添加如下等配置 1234567&lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/demo&lt;/path&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;finalName&gt;demo&lt;/finalName&gt; &lt;server&gt;tomcat7&lt;/server&gt; &lt;/configuration&gt; 参考：http://tomcat.apache.org/maven-plugin-2.2/]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>插件</tag>
        <tag>内嵌</tag>
        <tag>可执行</tag>
        <tag>war</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven项目中WEB模块中后台代码打成jar包]]></title>
    <url>%2F2018%2F12%2F03%2Fmaven%2FMaven%E9%A1%B9%E7%9B%AE%E4%B8%ADWEB%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%90%8E%E5%8F%B0%E4%BB%A3%E7%A0%81%E6%89%93%E6%88%90jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[原文地址 描述 将web模块的后台代码打成jar 包发布到target目录下（war包中正常编译的class依然存在） 123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-a-jar&lt;/id&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 将web模块的后台代码打成jar包发布到WEB_INF/lib下 123456789101112131415161718192021222324&lt;build&gt; &lt;finalName&gt;manage-elasticsearch-authorization&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;!-- 释放将项目的类文件打成jar放到lib目录中。 打成jar的好处是：只修改class时，可以只更新jar。 --&gt; &lt;archiveClasses&gt;true&lt;/archiveClasses&gt; &lt;webResources&gt; &lt;!-- src/main/resources是默认的资源目录。 当archiveClasses=true时，resources中的文件资源会被打到jar中； 当archiveClasses=false时，resources中的文件资源在war的根目录。 --&gt; &lt;resource&gt; &lt;!-- resources作为source folder，不会被打到jar中。 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;targetPath&gt;WEB-INF/classes&lt;/targetPath&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 以上内容仅为配置后台代码生成到jar包中，一般用于发布应用。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>jar</tag>
        <tag>后台</tag>
        <tag>程序</tag>
        <tag>代码</tag>
        <tag>lib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建WEB可执行的jar包]]></title>
    <url>%2F2018%2F12%2F02%2Fmaven%2F%E6%9E%84%E5%BB%BAWEB%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[原文地址 这个博客来自于很久在CSDN上写的，可能现在可能已经发生些变化，但是并不影响拿来参考借鉴它的使配置的方式和思想。 构建可执行jar包文档（tomcat7-maven-plugin）：JDK 1.7+Maven 3.0 or later tomcat7-maven-plugin version 2.1/2.0/2.0-beta-1 环境要求Unix System\windwos\macOSJDK 1.7+Maven 3.0 or later 我测试的编译环境是：macOS10.11.6和windows10jdk1.8/jdk1.7Maven 3.3.9我的本机开发环境：MacOS 10.11.6eclipse Mars.2 在pom中配置tomcat7-maven-plugin1234567891011121314151617181920212223242526272829&lt;project&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;tomcat-run&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;exec-war-only&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;configuration&gt; &lt;path&gt;demo&lt;/path&gt; &lt;!-- optional, needed only if you want to use a preconfigured server.xml file --&gt; &lt;serverXml&gt;src/main/tomcatconf/server.xml&lt;/serverXml&gt; &lt;!-- optional values which can be configurable --&gt; &lt;attachArtifactClassifier&gt;default value is exec-war but you can customize&lt;/attachArtifactClassifier&gt; &lt;attachArtifactClassifierType&gt;default value is jar&lt;/attachArtifactClassifierType&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 执行构建生成jar包执行 1mvn clean install 会在target下生成相应的jar包 如果想要修改jar包名称，可以在标签中定义标签修改生成的jar包名称 执行构建出来的jar包部署应用执行构建出来的jar包： 1java -jar yourjar 其他参数： 1234567891011121314151617181920usage: java -jar [path to your exec war jar] -ajpPort &lt;ajpPort&gt; ajp port to use -clientAuth enable client authentication for https -D &lt;arg&gt; key=value -extractDirectory &lt;extractDirectory&gt; path to extract war content, default value: .extract -h,--help help -httpPort &lt;httpPort&gt; http port to use -httpProtocol &lt;httpProtocol&gt; http protocol to use: HTTP/1.1 or org.apache.coyote.http11.Http11Nio Protocol -httpsPort &lt;httpsPort&gt; https port to use -keyAlias &lt;keyAlias&gt; alias from keystore for ssl -loggerName &lt;loggerName&gt; logger to use: slf4j to use slf4j bridge on top of jul -obfuscate &lt;password&gt; obfuscate the password and exit -resetExtract clean previous extract directory -serverXmlPath &lt;serverXmlPath&gt; server.xml to use, optional -X,--debug debug 例如：如果需要改变启动容器的端口号(默认为8080） 1java -jar yourjar -httpPort 8081 PS： 在测试过程中使用到的插件版本如下： 2.0、2.0-beta-1、2.1、2.2 都可以正常构建生成jar包，但是在执行启动jar包的过程中，在jdk1.8的环境下： 2.1的版本正常，可以正常执行部署，启动运行2.0和2.0-beta-1版本可以正常部署，但是启动tomcat访问中报java.io异常，和jdk执行版本有关，经过多次测试，更换为jdk1.7执行没有可以正常使用。在jdk1.8环境和jdk1.7环境下2.2版本都存在不可以正常创建webapp文件夹，也不可以将应用部署到webapp中，如果手动将jar包的相关内容部署进.extract/再次执行启动命令可以正常使用综上：可以使用2.1版本的插件。 在maven的web项目中内嵌tomcat插件执行war包环境要求Unix System\windwos\macOSJDK 1.7+Maven 3.0 or later 我测试的编译环境是：macOS10.11.6和windows10jdk1.8/jdk1.7Maven 3.3.9我的本机开发环境：MacOS 10.11.6eclipse Mars.2 在pom中配置tomcat-maven-plugin123456789101112131415161718192021222324&lt;project&gt; ... &lt;packaging&gt;war&lt;/packaging&gt; ... &lt;build&gt; ... &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat6-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; ... &lt;/plugins&gt; ... &lt;/build&gt; ...&lt;/project&gt; 运行war包执行 tomcat7:run-war或者tomca6:run-war 如果想要修改其他配置可以在 标签下添加如下等配置 1234567&lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/demo&lt;/path&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;finalName&gt;demo&lt;/finalName&gt; &lt;server&gt;tomcat7&lt;/server&gt; &lt;/configuration&gt; 参考文档]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>插件</tag>
        <tag>构建</tag>
        <tag>执行</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven依赖管理]]></title>
    <url>%2F2018%2F12%2F01%2Fmaven%2FMaven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[作者：李明明原文地址 直接依赖和间接依赖mane最大的好处就是能够方便的声明第三方的jar包，只需要在pom中进行简单的声明就可以将此jar包依赖到项目中，那什么是直接依赖呢？就是在项目中直接声明的这些依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 排除依赖间接依赖是由直接依赖间接依赖到项目的那些jar包，当项目依赖于某一第三方Jar包，而这一第三方Jar包又给我们间接性的带来了大量的依赖,这种间接性的依赖，不仅浪费了磁盘空间，而且也可能带来潜在的冲突,因此我们需要将这些不需要的依赖从项目中排除，对项目进行一个瘦身，这时我们需要对Pom进行优化,再或者，通过间接性依赖获得的Jar包版本过低，而这些低版本的Jar包无法满足我们项目的需求，这时我们也需要将这些低版本的Jar包排除掉，也就是下面的exclusion标签 1234567891011121314151617181920212223242526&lt;dependency&gt; &lt;groupId&gt;net.sf.spring-json&lt;/groupId&gt; &lt;artifactId&gt;spring-json&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib-full&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 工具筛选Maven没有任何声明排除jar包的情况下，默认是将全部jar包引入进来，有时候当前项目使用的jar包与依赖的第三方的jar包不同，会出现同个项目构建后出现一个jar包几个不同版本同时存在的问题，有时会引发jar包冲突可以通过命令或者是在IDE中查看依赖树，排查依赖关系： 1mvn dependency : list 经过Maven解析之后，就会构成一个依赖树也可以使用命令查看当前项目的依赖树： 1mvn dependency : tree 使用命令分析当前当前项目的依赖： 1mvn dependency : analyze 该命令执行结果的两个重要部分：Used undeclared dependencies: 表示项目中使用到的，但是没有显示声明的依赖Unused declared dependencies: 表示项目中未使用的，但显示声明的依赖该命令只会分析编译主代码和测试代码需要用到的依赖，一些执行测试和运行时需要的依赖它无法发现。 ps:exclusions是在某个具体依赖里面配置的，也就是说要找到需排除的jar包的依赖坐标 以下是eclipse中的通过配置工具查看依赖、删除依赖的位置： 大开pom.xml,选中下发Dependency Hierarchy，选中右侧jar包，右键排除依赖就可以了。 配置可选maven还有个可选依赖的设置，在当前项目A设置对某个依赖是可选的: 12345678&lt;optional&gt;true&lt;/optional&gt;&lt;dependency&gt; &lt;groupId&gt;sample.ProjectB&lt;/groupId&gt; &lt;artifactId&gt;Project-B&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 这样设置后，再有个项目X依赖A时，如果X中没有B中的类路径，则不会把B依赖加进来。 依赖规则大家看到直接依赖和间接依赖之后可能会有疑问，由不同的直接依赖产生的同一jar包不同版本的jar包之间的间接依赖怎么进行排除？这就要讲到maven的规则： 第一声明者优先（对于简介依赖） 例如：A项目依赖B、C两个项目，B和C又同时依赖D项目（依赖的D项目版本可能还是不同的），那就按照第一声明者优先的规则，谁先声明就用谁的，也就是对于间接依赖，路径相同的情况下，第一声明优先。 最后声明者优先（对于同一pom中直接依赖的同一jar包的不同版本间） 在pom中声明了同一jar包的不同版本，谁声明在后面就采用谁。 最短路径优先（对于间接依赖） 从名称就可以看出对于间接依赖的jar包，谁的间接依赖的路径短就采用谁的，例如A依赖B，B依赖D，而A依赖C，C依赖E，E依赖F，F依赖D，采用最短的依赖A-&gt;B-&gt;D的依赖版本。 dependencyManagement与dependenciesMaven已经具备了面向对象的思想，面向对象的三要素就是多态、继承、封装，dependencies与dependencyManagement就涉及到的是继承的思想。 多模块项目中，各个模块一般均需要Junit测试Jar包，因此在父Pom配置文件中，我们可以将这个依赖写入： 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 此模块的各个子模块就可以直接继承此jar包了。 再想想，有一些依赖，是各个子模块所特有的，如果放在父模块的POM中进行定义,那么所有继承了该父模块的子模块均会存在该依赖，这样的结果是啥，项目中存在大量冗余Jar包，不但浪费了磁盘，而且也不利于管理，所以： 12345678910111213141516171819dependencyManagement&gt; &lt;!-- 配置项目依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;zookeeper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.opensymphony.quartz&lt;/groupId&gt; &lt;artifactId&gt;quartz-all&lt;/artifactId&gt; &lt;version&gt;$&#123;quartz.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;oro&lt;/groupId&gt; &lt;artifactId&gt;oro&lt;/artifactId&gt; &lt;version&gt;$&#123;oro.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencyManagement&gt; 我们可以这样定义jar包在父模块，这样子模块就不会继承了，如果子模块需要用到jar包就需要重新声明： 1234567&lt;!-- 配置项目依赖 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 可以省略版本，这样有利于控制版本，当然也可以自己定义在子模块中版本，这样将采用子模块中的版本。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>依赖管理</tag>
        <tag>排除</tag>
        <tag>依赖</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK及openJDK版本更迭]]></title>
    <url>%2F2018%2F12%2F01%2FJava%2FJDK%E5%8F%8AopenJDK%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD%2F</url>
    <content type="text"><![CDATA[作者: 李明明http://limingming.org/index.php/2018/11/30/jdk-and-openjdk-version/ 道听途说最近浪潮公司内部除了持之以恒的宣扬“奋进者精神”之外，可能最大的一件事情就是JDK要收费了，观望着是不是要更换为openJDK，9月20多号Oracle发布了java 11，同时也发布后续更新策略，那是怎么收费的呢？ 追根溯源oracle jdk 和open jdk有什么区别？ Java 11授权使用BCL协议，没有个人、商业版了，也就是说，如果要使用的必须要付出代价，代价就是Money，不禁想说一句：万恶的资本主义。 Open jdk使用GPL协议 两种协议有什么区别呢？首先BCL不是开源协议，简要来介绍BCL协议的话，就是你一点也不能更改我的jdk，也不能基于我开发周边类库发布，如果基于我这个BCL开发，需要判断你是个人版还是商业版，再收钱！GPL是开源协议，JDK是可以更改的，基于这个GPL开发的东西也是属于GPL协议的，也要开源出来。 补充：由于历史原因，OpenJDK是JDK的开放源码版本，也就是上面我们说的GPL协议的，但是到了JDK7的时候OpenJDK已经为jdk的主干开发，oracle jdk是在openjdk基础上进行封板发布的，所以大部分的源代码是相同的，只不过其中有部分少量的源代码被替换掉，使用JRL发布，以上jdk7的过程中就产生了微妙的变化，openjdk 是GPL协议的，完全可以商用，但是JRL只允许个人使用不允许商用。 版本更迭大体梳理一下JDK版本更迭过程中产生了那些新特性，也借此机会梳理一下自己JAVA的知识脉络。 JDK5 泛型“ 123ArrayList list=new ArrayList()------&gt;ArrayList&lt;Integer&gt;list=new ArrayList&lt;Integer&gt;(); 枚举 静态导入 123456789101112import static java.lang.System.out``` 3. 可变参数（Varargs）4. 内省（Introspector），主要用于操作JavaBean中的属性，通过getXxx/setXxx。一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。泛型(Generic)（包括通配类型/边界类型等）5. For-Each循环 ```javai=0;i&lt;a.length;i++------------&gt;for(int i:a)&#123;......&#125; 注解 协变返回类型：实际返回类型可以是要求的返回类型的一个子类型 自动装箱拆箱： 123int i=list.get(0).parseInt();--------&gt;int i=list.get(0); 我们经常阅读的编程思想也是在jdk5的版本上进行编写的，可惜作者忙别的事情去了，没有更新了，可能觉得java更新至此也应该很全面了吧。 JDK6 AWT新增加了两个类:Desktop和SystemTray，其中前者用来通过系统默认程序来执行一个操作，如使用默认浏览器浏览指定的URL,用默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件),用系统默认的打印机打印文档等。后者可以用来在系统托盘区创建一个托盘程序。 使用JAXB2来实现对象与XML之间的映射，可以将一个Java对象转变成为XML格式，反之亦然 StAX，一种利用拉模式解析(pull-parsing)XML文档的API。类似于SAX，也基于事件驱动模型。之所以将StAX加入到JAXP家族，是因为JDK6中的JAXB2和JAX-WS 2.0中都会用StAX。 使用Compiler API，动态编译Java源文件，如JSP编译引擎就是动态的，所以修改后无需重启服务器。（刚知道是从这里开始可以动态编译的） 轻量级Http Server API，据此可以构建自己的嵌入式HttpServer,它支持Http和Https协议。 插入式注解处理API(PluggableAnnotation Processing API) 提供了Console类用以开发控制台程序，位于java.io包中。据此可方便与Windows下的cmd或Linux下的Terminal等交互。 对脚本语言的支持如: ruby,groovy, javascript Common Annotations，原是J2EE 5.0规范的一部分，现在把它的一部分放到了J2SE 6.0中 嵌入式数据库 Derby 增强的for循环语句 1234567Integer[] numbers = computeNumbers();for (int i=0; i &lt; numbers.length ; i++)sum += numbers[i];||int sum = 0;for ( int number: computeNumbers() )sum += number; 监视和管理Java SE 6中对内存泄漏增强了分析以及诊断能力。当遇到java.lang.OutOfMemory异常的时候，可以得到一个完整的堆栈信息，并且当堆已经满了的时候，会产生一个Log文件来记录这个致命错误。另外，JVM还添加了一个选项，允许你在堆满的时候运行脚本。 插入式注解处理插入式注解处理API(JSR 269)提供一套标准API来处理Annotations 安全性 如果你细细想来jdk6用到的新特性的确很少 JDK7 对Java集合（Collections）的增强支持，可直接采用[]、{}的形式存入对象，采用[]的形式按照索引、键值来获取集合中的对象。如： 12345List&lt;String&gt;list=[“item1”,”item2”];//存Stringitem=list[0];//直接取Set&lt;String&gt;set=&#123;“item1”,”item2”,”item3”&#125;;//存Map&lt;String,Integer&gt; map=&#123;“key1”:1,”key2”:2&#125;;//存Intvalue=map[“key1”]; 在Switch中可用String 数值可加下划线用作分隔符（编译时自动被忽略） 支持二进制数字，如： 12345678910int binary= 0b1001_1001; ``` 5. 简化了可变参数方法的调用 6. 调用泛型类的构造方法时，可以省去泛型参数，编译器会自动判断。 7. Boolean类型反转，空指针安全,参与位运算 8. char类型的equals方法: ```javabooleanCharacter.equalsIgnoreCase(char ch1, char ch2) 安全的加减乘除: 1Math.safeToInt(longv); Math.safeNegate(int v); Math.safeSubtract(long v1, int v2);Math.safeMultiply(int v1, int v2); Map集合支持并发请求，注HashTable是线程安全的，Map是非线程安全的。但此处更新使得其也支持并发。另外，Map对象可这样定义： 1Map map = &#123;name:”xxx”,age:18&#125;; JDK8 接口的默认方法：即接口中可以声明一个非抽象的方法做为默认的实现，但只能声明一个，且在方法的返回类型前要加上“default”关键字。2.Lambda 表达式：是对匿名比较器的简化，如： 1Collections.sort(names,(String a, String b) -&gt; &#123; returnb.compareTo(a);&#125;); 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字。如： 123456Collections.sort(names,(String a, String b) -&gt; b.compareTo(a));``` 或：```javaCollections.sort(names, (a, b) -&gt; b.compareTo(a)); 函数式接口：是指仅仅只包含一个抽象方法的接口，要加@FunctionalInterface注解 使用 :: 关键字来传递方法或者构造函数引用 多重注解 还增加了很多与函数式接口类似的接口以及与Map相关的API等 其实以上的只不过是对于各个版本功能的简要摘录，如果想要详细了解的话可以看官方文档，平时用到的就是到jdk8，从jdk5到现在用jdk8，jdk9、和10还从来没有接触过。 最后附上相关项目的地址： OpenJDK官网:http://openjdk.java.net/ OpenJDK源码库：http://hg.openjdk.java.net/ OpenJDK源码库：http://hg.openjdk.java.net/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>open jdk</tag>
        <tag>版本</tag>
        <tag>功能</tag>
        <tag>区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下npm安装命令不生效]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%2Fmac%E4%B8%8Bnpm%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E4%B8%8D%E7%94%9F%E6%95%88%2F</url>
    <content type="text"><![CDATA[介绍如果我们平时使用node进行开发的话，经常会使用node安装一些其他的命令，比如安装淘宝的cnpm（npm install -g cnpm –registry=https://registry.npm.taobao.org），安装vue（npm install vue）命令等等，按道理应该是命令可以直接使用的。 我们在mac上安装完成nodejs，node的命令是在/usr/local/bin下面，可以直接使用，但是我们通过node命令安装的其他工具是在/usr/local/Cellar/node/10.8.0/lib/node_modules/vue-cli/bin/vue,我使用的10.8.0的版本，如果使用其他版本会在其他版本号路径下面，这个安装的路径一般都会统一创建链接到/usr/local/Cellar/node/10.8.0/bin下，所以我们把这个路径添加到我们的环境变量里面就可以了。 解决办法添加到环境变量的一个方式，比如修改~/.bash_profile文件，添加： 12#node安装包下的相关命令cnpm、node等命令export PATH="$PATH:/usr/local/Cellar/node/10.8.0/bin" 执行: 1source ~/.bash_profile 就可以使用cnpm等命令了。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>命令</tag>
        <tag>Mac</tag>
        <tag>npm</tag>
        <tag>不生效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[作者 李明明转载请注明出处： http://limingming.org/index.php/2018/11/28/markdown-grammar/ 介绍 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科;Markdown 是一种轻量级标记语言，让写作者专注于写作而不用关注样式。很多有编程基础的程序员比较喜欢使用Markdown进行编写，github项目中README.md都是markdown编写的；以下我讲述通用的语法，保留各个编辑器通用的，还有很多markdown语法是各个编辑器独有的，大家使用过程中可以注意一下，平时使用mac上的编辑器,也为大家分享一下。 语法介绍标题123# 一级标题## 二级标题### 三级标题 演示图效果： 强调 在Markdown中，可以使用 * 或 _ 来表示斜体和加粗。 使用一个*或者_来表示斜体，两个来表示加粗。1234A： *我是斜体*B: _我也是斜体_C：**我是粗体**D: __我也是粗体__ 演示图效果： 例子（摘抄于马克飞象“案例，马克飞象是一个很不错的markdown编辑器，为markdown各种类型的语法提供了一个良好的支持）12345**马克飞象**是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： - **功能丰富** ：支持高亮代码块、*LaTeX* 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；- **得心应手** ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web；- **深度整合** ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 锚点markdown会针对每个标题，在解析时都会添加锚点 id，例如： 123# 介绍# 介绍1那我们就可以使用“[访问介绍标题的锚点](#介绍)”,来定义锚点 测试： 访问介绍标题的锚点; 引用Markdown 标记区块引用和 email 中用 &gt; 的引用方式类似，只需要在整个段落的第一行最前面加上 &gt; ： 演示： 列表标记通常放在句子最左边，项目标记后面要接一个字符的空格。 无序列表：使用星号、加号或是减号作为列表标记123* 我是无序列表A + 我是无序列表B - 我是无序列表C 有序列表：使用数字接着一个英文句点1231. 我是无序列表12. 我是无序列表2 3. 我是无序列表3 3.代办列表(简书暂不支持此方式）12- [ ] 不勾选- [x] 勾选 补充如果在列表中使用引用,需要换行缩进，一般为四个空格：12345* 演示内容： &gt; 引用部分1 &gt; 引用部分2 &gt; 引用部分3 &gt; 引用部分4 代码块使用`包裹代码块，并声明代码块的语言，一般会带有相关的解析插件，对代码进行高亮处理，对代码进行着色。 超链接方括号显示说明，圆括号内显示网址， Markdown 编辑器会自动把它转成链接；123[我的博客](https://blog.csdn.net/limm33)[编程者联盟](https://github.com/limm33/ProgrammerLeague/blob/master/ProgrammerLeague.jpg)[个人博客](http://www.limingming.org) 演示： 图片图片和超连接语法比较像，可以在方括号前面加一个！就变成了引用图片了；1234![编程者联盟](url) 或者：![卡卡西](/Users/limm/Pictures/火影忍者/30381-106.jpg) 相对路径也可以(./path/*.jpg)这种形式 分割线使用 3 个以上 - 符号制作分割线：123分割线以上内容------------------分割线以下内容 演示： 表格markdown可以制作表格，方法也很简单例如：1233 | 3 | 3-|-|-3| 3| 3 以上为最基本的结构，‘3’代表你编辑的内容，第一行为表头，但是有的编辑器 - 需要多个，有的需要至少三个，所以布局可以尽量美观：123一列 | 第二列 | 第三列---------|---------------|---------- 值1 | 值2 | 值3 演示： 可以设置对齐方式,使用 ：添加在列的左边左对齐，右边为右对齐，两边都添加就是中间对齐：1234一列 | 第二列 | 第三列:---------|---------------:|:----------: 值1 | 值2 | 值3 值3 | 值4 | 值5 演示： 以上为总结的markdown的语法，希望对你的编写有所帮助。 联系我原来一直在CSDN编写博客我的博客我的微信公众号:编程者联盟我的 个人博客我的QQ群：115402375]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>介绍</tag>
        <tag>markdown</tag>
        <tag>语法</tag>
        <tag>怎么</tag>
        <tag>如何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下chromium源码编译笔记]]></title>
    <url>%2F2018%2F11%2F25%2F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%2Fmac%E4%B8%8Bchromium%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[作者 李明明转载请注明出处： http://limingming.org/index.php/2018/11/28/mac-compile-chromium/ 背景因为项目需要，需要对chromium进行了解，对chromium进行编译，在官网上可以通过：网址，找到各个平台相关详细的介绍，介绍文档这个是mac下编译chromium的讲解，本篇文章是针对于官方介绍文档的中文版，对其中编译过程中遇到的问题进行记录。 因为国内特殊的原因，谷歌相关的网络请求被墙掉了，所有需要配置科学上网能够翻墙的工具，我使用的是自己搭建的shadowsocks，shadowsocks搭建在这里就不细说了，由于需要chromium源码及depots_tools工具需要git命令下载，所以设置http_proxy，通过搭建好的shadowsocks可以通过下图中的方式获取到设置方式在终端中执行就行了，就可以在终端中请求被墙的网络地址了，具体设置git请求的设置和让终端走代理的设置大家可以百度一下，看一下详细的配置，自己设置一下， export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087; ​ 系统要求：64位mac,系统版本10.11+系统版本，屏幕左上角 苹果图标 -&gt; 关于本机 -&gt; 概览 Xcode 7.3+在 App Store搜索下载 OSX 10.10 SDK装完Xcode以后在终端输入下面的代码，如下图所示应该就可以了 1$ ls `xcode-select -p`/Platforms/MacOSX.platform/Developer/SDKs ​ 安装depot_tools用git复制 depot_tools 资源，如果一直下载不成功，检查一下http_proxy是否设置成功 1$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 把depot_tools加入路径,假设你放在/path/to/depot_tools路径下面，那么就在终端输入，不过这是临时的， 1$ export PATH=&quot;$PATH:/path/to/depot_tools&quot; 获取代码创建一个新的chromium文件夹并进入文件夹，你可以叫它别的名字，可以放在任意的位置，但是要保证路径没有空格 1$ mkdir chromium &amp;&amp; cd chromium 使用fetch来检出代码和依赖（这个代码我现在下大概是7.2GB，如果不想要所有的历史记录可以加–no-history，下载会快一点） 带历史记录的源码 1$ fetch chromium 不带历史记录的源码 1$ fetch --no-history chromium 会产生隐藏的.gclient的文件，如果下载失败，可以把这个文件删了重新执行 中间不会有任何的提示，请安静地等待~这种应该是下载成功了吧 ​然后你就会发现目录下面有src文件夹，进入文件夹，这里有提示install API keys ，但是对大多数的开发者不是必选项，所以就先跳过。在官网上没有详细介绍， 开始编译： 在编译之前要执行gclient sync和gclient runhooks，进入到src目录下，在src目录啊下编译，之前装了depot_tools，那么就可以用下面的代码开新建一个build的目录文件夹，（build可以换名字，但是out文件夹是必需的） gn gen out/build 更快地编译官网给了三个配置可以加快build，分别是is_debug，is_component_build，symbol_level，配置方式如下(关于配置的说明) 输入下面的命令行会打开一个配置文件 1gn args out/build 可以在文件里面输入配置，像下面展示的这样 123is_component_build = trueis_debug = falsesymbol_level = 0 其实他们应该保存在src/out/build/args.gn这边 输入下面的代码你能够查看所有可配置的参数以及他们的默认值 1gn args --list out/my_build 同时也可以通过install ccache ，在再次compile的时候会更快，会增量编译不会重复编译 build chromium使用Ninja来build chromium，这个过程会比较耗时，虽然很多人说等2个小时，我第一次编译用了5个小时 1$ ninja -C out/Default chrome 运行chromium输入 1$ out/Default/chrome Debugging 调试debug资料这里的意思是用图形化的环境不用在xcode里面配置Debugging in Xcode前面按照教程取消了crash的记录 最后的配置是在生成的文件夹下面找到products.xcodeproj，然后双击就会用xcode打开，然后配置scheme,第一次应该没有scheme配置，选择New Scheme，然后Info这边，Executable选择Chromium.app，‘ 然后启动chromium , Debug -》Attach to Processes -&gt; 选择Chomium程序 首先是第一个资料推荐苹果开发者阅读的Mac OS X Debugging Magic Technote重要提醒： 在xcode里面，为了让断点生效，Debugging面板中取消Load Symbols Lazily GYP_DEFINES的fast_build如果是1的话，那么你想要的断点可能拿不到,如果你去掉它，要重新运行gyp_chromium以及rebuild禁用ReportCrash，在终端输入man ReportCrash，然后找到这一行 ​ 12launchctl unload -w /System/Library/LaunchAgents/com.apple.ReportCrash.plistsudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.ReportCrash.Root.plist 调试渲染进程XCode本身不支持多于一个的进程，对子进程的支持也不友好，有两种方法应付。 (a)单进程运行chrome（不被推荐） CCache据说是加速recompilation的，他通过存储原来的compilation，当compilations相同的时候，能够有一个显著的加速，特别是切换分支的时候。首先用brew下载在环境变量里面配置 ，下面是临时的 1Export PATH=“$PATH:/usr/local/opt/ccache/libexec ccahe” 然后要让gn配置使用配置环境变量 123export CCACHE_CPP2=yesexport CCACHE_SLOPPINESS=time_macrosexport PATH=`pwd`/third_party/llvm-build/Release+Asserts/bin:$PATH 运行 ninja ninja -C out/Release chrome 推荐大家可以看一下《webkit技术内幕》 联系我原来一直在CSDN编写博客我的博客我的微信公众号:编程者联盟我的 个人博客我的QQ群：115402375]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>搭建</tag>
        <tag>源码</tag>
        <tag>chromium</tag>
        <tag>谷歌浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS下搭建Vue开发环境]]></title>
    <url>%2F2018%2F11%2F23%2Fvue%2FMac-OS%E4%B8%8B%E6%90%AD%E5%BB%BAVue%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言原来一直学习使用React，现在因为工作的需要，对Vue进行学习和使用，现在比较流行的框架React,angular,vue，正好对于vue也进行些了解。 环境搭建 打开终端,安装brew 1usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装成功后，使用查看版本，验证是否安装成功1brew -v 安装node.js1brew install nodejs 也可以下载安装下载地址安装成功后，使用验证123node -v``` * 给nodejs目录赋权限 sudo chmod -R 777 /usr/local/lib/node_modules/1* 安装 淘宝镜像 （npm） npm install -g cnpm –registry=https://registry.npm.taobao.org12* 安装webpack cnpm install webpack -g12* 安装vue脚手架 npm install vue-cli -g12# 开始Vue 创建一个基于 webpack 模板的新项目$ vue init webpack my-project 这里需要进行一些配置，默认回车即可This will install Vue 2.x version of the template. For Vue 1.x use: vue init webpack#1.0 my-project ? Project name my-project? Project description A Vue.js project? Author runoob &#116;&#x65;&#115;&#116;&#x40;&#114;&#x75;&#110;&#111;&#111;&#x62;&#x2e;&#99;&#x6f;&#x6d;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated “my-project”. To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack1进入项目，安装并运行： $ cd my-project$ cnpm install$ cnpm run dev DONE Compiled successfully in 4388ms Listening at http://localhost:8080`]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>搭建</tag>
        <tag>Vue</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wordpress无法连接到FTP解决]]></title>
    <url>%2F2018%2F11%2F23%2F%E6%9D%82%E8%B0%88%2Fwordpress%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0FTP%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题未能连接到FTP服务器IP:21 原因分析为了安全起见，wordpress会在安装插件或者主题时增加一层FTP验证 解决 修改wordpress 根目录下wp-config.php文件 1vi wordpress/wp-config.php 在文件最后添加一行内容 1define(&apos;FS_METHOD&apos;, &quot;direct&quot;); 重新试试就可以了！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>解决</tag>
        <tag>wordpress</tag>
        <tag>无法连接</tag>
        <tag>FTP</tag>
        <tag>下载插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC-OS无法开机问题解决]]></title>
    <url>%2F2018%2F11%2F11%2F%E6%9D%82%E8%B0%88%2FMAC-OS%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[作为一个自恋的程序员，我的imac升级了系统之后也变得傲娇起来，就是开机无法启动，进度条大约到五分之四的时候就卡住了，电脑也变黑屏了，之后进入了小圆圈一直转的无限循环的状态，暂时简称无限菊花状态。 问题导致原因原来mac系统为10.13.6，升级到了最新的系统之后10.14.8,虽然更新过程中没有任何问题，也能重新启动了电脑，有了新的黑色主题的imac并没有让我适应，总感觉还是原来的主题比较好，再不高兴之余骂了它的主题，顺便关了机，所以它就闹起了小脾气。 问题解决 首先想到的是“开机按住shift键进入安全模式，结果无法启动； 所以无耻的google了一下，按照说明开机无法启动的情况下，按住电源按钮十秒；钟，当然我很坚持的按住了15秒钟，隐隐若若的听到了“嗒”的一个内部的声音，感觉有什么东西被重置了的感觉，但是也是无济于事； 之后按照重置 Mac 上的系统管理控制器 (SMC),按照配置重置了smc，结果仍然不能开机； 按照重置 Mac 上的 NVRAM 或 PRAM重置了，原来电脑是静音状态，重置了之后生效了开机声音，可以听到开机声音了； 经过了以上几个步骤还是不能开机，所以我觉得应该弄点大招了，所以开机使用“command+r”的方式进入恢复模式选择磁盘工具，进行急救，修复了文件权限和磁盘，当然我没有进行任何磁盘破坏的事情，我很确信是因为升级导致的无法启动，所以磁盘急救完成重新开机竟然还是不行； 在磁盘急救不生效的情况下，用command+r进入恢复模式，重新安装系统，此种方式安装系统不会丢失任何文件和应用，可以放心安装，可能因为网络和时区的问题，导致无法正常安装，可以多试几次；但是重装覆盖系统之后还是不能开机。 在恢复模式下磁盘工具中抹掉磁盘，当然要备份好重要数据后抹掉磁盘，然后再执行安装系统，完成后就可以正常开机了。 说明以上几个步骤我在执行过程中可能没有生效，但是很多遇到这种情况的执行其中几步的时候都成功开机了，在万不得已的情况下可以抹掉磁盘重新安装系统。 联系我原来一直在CSDN编写博客我的博客，欢迎留言讨论，现在第一次更换为简书，竟然写的不是技术博客。我的微信公众号:编程者联盟 我的QQ群：115402375]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>苹果电脑</tag>
        <tag>无法开机</tag>
        <tag>解决</tag>
        <tag>转圈</tag>
      </tags>
  </entry>
</search>
